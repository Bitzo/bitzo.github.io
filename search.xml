<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2017/05/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】10 JavaScript concepts</title>
    <url>/2017/07/23/node/10-JavaScript-concepts/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="http://www.techug.com/post/10-javascript-concepts-every-programmer-must-master.html">http://www.techug.com/post/10-javascript-concepts-every-programmer-must-master.html</a><br>原文：<a href="http://www.infoworld.com/article/3196070/node-js/10-javascript-concepts-nodejs-programmers-must-master.html">10 JavaScript concepts every Node.js programmer must master</a></p>
</blockquote>
<span id="more"></span>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p><strong>立即执行函数</strong>，即 Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// 代码</span></span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>function(){…}</strong> 是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。<strong>立即执行函数</strong>也可以理解为立即调用一个匿名函数。<strong>立即执行函数</strong>最常见的应用场景就是：将 var 变量的作用域限制于你们函数内，这样可以避免命名冲突。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>对于闭包 (closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="number">0</span>; <span class="comment">// N是f1函数的局部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) <span class="comment">// f2是f1函数的内部函数，是闭包</span></span><br><span class="line">    &#123;</span><br><span class="line">        N += <span class="number">1</span>; <span class="comment">// 内部函数f2中使用了外部函数f1中的变量N</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出1</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出2</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure>

<p>代码中，外部函数 <strong>f1</strong> 只执行了一次，变量 <strong>N</strong> 设为 <strong>0</strong>，并将内部函数 <strong>f2</strong> 赋值给了变量 <strong>result</strong>。由于外部函数 <strong>f1</strong> 已经执行完毕，其内部变量 <strong>N</strong> 应该在内存中被清除，然而事实并不是这样：我们每次调用 <strong>result</strong> 的时候，发现变量 <strong>N</strong> 一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>
<h2 id="使用闭包定义私有变量"><a href="#使用闭包定义私有变量" class="headerlink" title="使用闭包定义私有变量"></a>使用闭包定义私有变量</h2><p>通常，JavaScript 开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Product</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">p.<span class="title function_">setName</span>(<span class="string">&quot;Fundebug&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">getName</span>()); <span class="comment">// 输出Fundebug</span></span><br></pre></td></tr></table></figure>

<p>代码中，对象 <strong>p</strong> 的的 <strong>name</strong> 属性为私有属性，使用 <strong>p.name</strong> 不能直接访问。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个 JavaScript 构造函数都有一个 <strong>prototype</strong> 属性，用于设置所有实例对象需要共享的属性和方法。<strong>prototype</strong> 属性不能列举。JavaScript 仅支持通过 <strong>prototype</strong> 属性进行继承属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params">x, y</span>)&#123;<span class="variable language_">this</span>.<span class="property">_length</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_breadth</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getDimensions</span> = <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">length</span>: <span class="variable language_">this</span>.<span class="property">_length</span>,</span><br><span class="line">        <span class="attr">breadth</span>: <span class="variable language_">this</span>.<span class="property">_breadth</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">getDimensions</span>()); <span class="comment">// &#123; length: 3, breadth: 4 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y.<span class="title function_">getDimensions</span>()); <span class="comment">// &#123; length: 4, breadth: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<p>代码中，<strong>x</strong> 和 <strong>y</strong> 都是构造函数 <strong>Rectangle</strong> 创建的对象实例，它们通过 prototype 继承了 getDimensions 方法。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>JavaScript 并非模块化编程语言，至少 ES6 落地之前都不是。然而对于一个复杂的 Web 应用，模块化编程是一个最基本的要求。这时，可以使用<strong>立即执行函数</strong>来实现模块化，正如很多 JS 库比如 <a href="https://github.com/jquery/jquery">jQuery</a> 以及我们 <a href="https://fundebug.com/">Fundebug</a> 都是这样实现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> =(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">var</span> N = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The result is: &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = a + N;</span><br><span class="line">        <span class="title function_">print</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;This is description&quot;</span>,</span><br><span class="line">        <span class="attr">add</span>: add</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">description</span>); <span class="comment">// 输出&quot;this is description&quot; </span></span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">add</span>(<span class="number">5</span>); <span class="comment">// 输出“The result is: 10”</span></span><br></pre></td></tr></table></figure>

<p>所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module 为一个独立的模块，<strong>N</strong> 为其私有属性，<strong>print</strong> 为其私有方法，<strong>decription</strong> 为其公有属性，<strong>add</strong> 为其共有方法。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript 会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的**变量提升 (Hoisting)**。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。</p>
<p>但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y);  <span class="comment">// 输出undefined</span></span><br><span class="line">y = <span class="number">2</span>; <span class="comment">// 初始化y</span></span><br></pre></td></tr></table></figure>

<p>上面的代码等价于下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y;  <span class="comment">// 声明y</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y);  <span class="comment">// 输出undefined</span></span><br><span class="line">y = <span class="number">2</span>; <span class="comment">// 初始化y</span></span><br></pre></td></tr></table></figure>

<p>为了避免 BUG，开发者应该在每个作用域开始时声明变量和函数。</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化，即 <strong>Currying</strong>，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add =<span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">1</span>)); <span class="comment">// 输出2</span></span><br><span class="line"><span class="keyword">var</span> add1 = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add1</span>(<span class="number">1</span>)); <span class="comment">// 输出2</span></span><br><span class="line"><span class="keyword">var</span> add10 = <span class="title function_">add</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add10</span>(<span class="number">1</span>)); <span class="comment">// 输出11</span></span><br></pre></td></tr></table></figure>

<p>代码中，我们可以一次性传入 2 个 1 作为参数 **add(1)(1)**，也可以传入 1 个参数之后获取 <strong>add1</strong> 与 <strong>add10</strong> 函数，这样使用起来非常灵活。</p>
<h2 id="apply-call-与-bind-方法"><a href="#apply-call-与-bind-方法" class="headerlink" title="apply, call 与 bind 方法"></a>apply, call 与 bind 方法</h2><p>JavaScript 开发者有必要理解 <strong>apply</strong>、<strong>call</strong> 与 <strong>bind</strong> 方法的不同点。它们的共同点是第一个参数都是 <strong>this</strong>，即函数运行时依赖的上下文。</p>
<p>三者之中，<strong>call</strong> 方法是最简单的，它等价于指定 <strong>this</strong> 值调用函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Rahul Mhatre&quot;</span>,</span><br><span class="line">    <span class="attr">whatIsYourName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="title function_">whatIsYourName</span>(); <span class="comment">// 输出&quot;Rahul Mhatre&quot;,</span></span><br><span class="line"><span class="keyword">var</span> user2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Neha Sampat&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="property">whatIsYourName</span>.<span class="title function_">call</span>(user2); <span class="comment">// 输出&quot;Neha Sampat&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>apply</strong> 方法与 <strong>call</strong> 方法类似。两者唯一的不同点在于，<strong>apply</strong> 方法使用数组指定参数，而 <strong>call</strong> 方法每个参数单独需要指定：</p>
<ul>
<li><strong>apply(thisArg, [argsArray])</strong></li>
<li><strong>call(thisArg, arg1, arg2, …)</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user =&#123;</span><br><span class="line">    <span class="attr">greet</span>: <span class="string">&quot;Hello!&quot;</span>,</span><br><span class="line">    <span class="attr">greetUser</span>: <span class="keyword">function</span>(<span class="params">userName</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">greet</span> + <span class="string">&quot; &quot;</span> + userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> greet1 = &#123;</span><br><span class="line">    <span class="attr">greet</span>: <span class="string">&quot;Hola&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="property">greetUser</span>.<span class="title function_">call</span>(greet1, <span class="string">&quot;Rahul&quot;</span>); <span class="comment">// 输出&quot;Hola Rahul&quot;</span></span><br><span class="line">user.<span class="property">greetUser</span>.<span class="title function_">apply</span>(greet1, [<span class="string">&quot;Rahul&quot;</span>]); <span class="comment">// 输出&quot;Hola Rahul&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 <strong>bind</strong> 方法，可以为函数绑定 <strong>this</strong> 值，然后作为一个新的函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user =&#123;</span><br><span class="line">     <span class="attr">greet</span>: <span class="string">&quot;Hello!&quot;</span>,</span><br><span class="line">     <span class="attr">greetUser</span>: <span class="keyword">function</span>(<span class="params">userName</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">greet</span> + <span class="string">&quot; &quot;</span> + userName);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> greetHola = user.<span class="property">greetUser</span>.<span class="title function_">bind</span>(&#123;<span class="attr">greet</span>: <span class="string">&quot;Hola&quot;</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> greetBonjour = user.<span class="property">greetUser</span>.<span class="title function_">bind</span>(&#123;<span class="attr">greet</span>: <span class="string">&quot;Bonjour&quot;</span>&#125;);</span><br><span class="line"><span class="title function_">greetHola</span>(<span class="string">&quot;Rahul&quot;</span>) <span class="comment">// 输出&quot;Hola Rahul&quot;</span></span><br><span class="line"><span class="title function_">greetBonjour</span>(<span class="string">&quot;Rahul&quot;</span>) <span class="comment">// 输出&quot;Bonjour Rahul&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h2><p><strong>Memoization</strong> 用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memoizeFunction</span>(<span class="params">func</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> cache =&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (cache[key])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> val = func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            cache[key] = val;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fibonacci = <span class="title function_">memoizeFunction</span>(<span class="keyword">function</span>(<span class="params">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) ? n : <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">100</span>)); <span class="comment">// 输出354224848179262000000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">100</span>)); <span class="comment">// 输出354224848179262000000</span></span><br></pre></td></tr></table></figure>

<p>代码中，第 2 次计算 <strong>fibonacci(100)</strong> 则只需要在内存中直接读取结果。</p>
<h2 id="函数重载-还没看懂"><a href="#函数重载-还没看懂" class="headerlink" title="函数重载 (还没看懂)"></a>函数重载 <em>(还没看懂)</em></h2><p>所谓<strong>函数重载 (method overloading)<strong>，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，</strong>函数重载</strong>可以通过 <strong>if…else</strong> 或者 <strong>switch</strong> 实现，这就不去管它了。jQuery 之父 John Resig 提出了一个非常巧 (bian) 妙 (tai) 的方法，利用了闭包。</p>
<p>从效果上来说，<strong>people</strong> 对象的 <strong>find</strong> 方法允许 3 种不同的输入: 0 个参数时，返回所有人名；1 个参数时，根据 firstName 查找人名并返回；2 个参数时，根据完整的名称查找人名并返回。</p>
<p>难点在于，<strong>people.find</strong> 只能绑定一个函数，那它为何可以处理 3 种不同的输入呢？它不可能同时绑定 3 个函数 <strong>find0</strong>,<strong>find1</strong> 与 <strong>find2</strong> 啊！这里的关键在于 <strong>old</strong> 属性。</p>
<p>由 <strong>addMethod</strong> 函数的调用顺序可知，<strong>people.find</strong> 最终绑定的是 <strong>find2</strong> 函数。然而，在绑定 <strong>find2</strong> 时，<strong>old</strong> 为 <strong>find1</strong>；同理，绑定 <strong>find1</strong> 时，<strong>old</strong> 为 <strong>find0</strong>。3 个函数 <strong>find0</strong>,<strong>find1</strong> 与 <strong>find2</strong> 就这样通过闭包链接起来了。</p>
<p>根据 <strong>addMethod</strong> 的逻辑，当 <strong>f.length</strong> 与 <strong>arguments.length</strong> 不匹配时，就会去调用 <strong>old</strong>，直到匹配为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addMethod</span>(<span class="params">object, name, f</span>)</span><br><span class="line">&#123;　　</span><br><span class="line">    <span class="keyword">var</span> old = object[name];　　</span><br><span class="line">    object[name] = <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">    &#123;<span class="comment">// f.length为函数定义时的参数个数</span></span><br><span class="line">        <span class="comment">// arguments.length为函数调用时的参数个数　　　　</span></span><br><span class="line">        <span class="keyword">if</span> (f.<span class="property">length</span> === <span class="variable language_">arguments</span>.<span class="property">length</span>)</span><br><span class="line">        &#123;　　</span><br><span class="line">            <span class="keyword">return</span> f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);　　　　</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> old === <span class="string">&quot;function&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> old.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);　　　　</span><br><span class="line">        &#125;　　</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不传参数时，返回所有name</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find0</span>(<span class="params"></span>)</span><br><span class="line">&#123;　　</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">names</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传一个参数时，返回firstName匹配的name</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find1</span>(<span class="params">firstName</span>)</span><br><span class="line">&#123;　　</span><br><span class="line">    <span class="keyword">var</span> result = [];　　</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">names</span>.<span class="property">length</span>; i++)</span><br><span class="line">    &#123;　　　　</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">names</span>[i].<span class="title function_">indexOf</span>(firstName) === <span class="number">0</span>)</span><br><span class="line">        &#123;　　　　　　</span><br><span class="line">            result.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">names</span>[i]);　　　　</span><br><span class="line">        &#125;　　</span><br><span class="line">    &#125;　　</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传两个参数时，返回firstName和lastName都匹配的name</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find2</span>(<span class="params">firstName, lastName</span>)</span><br><span class="line">&#123;　</span><br><span class="line">    <span class="keyword">var</span> result = [];　　</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">names</span>.<span class="property">length</span>; i++)</span><br><span class="line">    &#123;　　　　</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">names</span>[i] === (firstName + <span class="string">&quot; &quot;</span> + lastName))</span><br><span class="line">        &#123;　　　　　　</span><br><span class="line">            result.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">names</span>[i]);　　　　</span><br><span class="line">        &#125;　　</span><br><span class="line">    &#125;　　</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> people = &#123;　　</span><br><span class="line">    <span class="attr">names</span>: [<span class="string">&quot;Dean Edwards&quot;</span>, <span class="string">&quot;Alex Russell&quot;</span>, <span class="string">&quot;Dean Tom&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">addMethod</span>(people, <span class="string">&quot;find&quot;</span>, find0);</span><br><span class="line"><span class="title function_">addMethod</span>(people, <span class="string">&quot;find&quot;</span>, find1);</span><br><span class="line"><span class="title function_">addMethod</span>(people, <span class="string">&quot;find&quot;</span>, find2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">find</span>()); <span class="comment">// 输出[&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">find</span>(<span class="string">&quot;Dean&quot;</span>)); <span class="comment">// 输出[&quot;Dean Edwards&quot;, &quot;Dean Tom&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">find</span>(<span class="string">&quot;Dean&quot;</span>, <span class="string">&quot;Edwards&quot;</span>)); <span class="comment">// 输出[&quot;Dean Edwards&quot;]</span></span><br></pre></td></tr></table></figure>

<br>]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】征服JavaScript面试系列：类继承和原型继承的区别</title>
    <url>/2017/11/28/node/JS-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="征服JavaScript面试系列：类继承和原型继承的区别"><a href="#征服JavaScript面试系列：类继承和原型继承的区别" class="headerlink" title="征服JavaScript面试系列：类继承和原型继承的区别"></a>征服JavaScript面试系列：类继承和原型继承的区别</h1><blockquote>
<p>本文转载自：<a href="http://www.zcfy.cc/">众成翻译</a><br>译者：<a href="http://www.zcfy.cc/@msbhb5">主小席</a><br>链接：<a href="http://www.zcfy.cc/article/2185">http://www.zcfy.cc/article/2185</a><br>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.d84c324od">https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.d84c324od</a></p>
</blockquote>
<p><img src="http://p0.qhimg.com/t018bd413601b3b9a4a.jpg" alt="图-电子吉他-Feliciano Guimarães（CC BY 2.0"></p>
<p>图-电子吉他-Feliciano Guimarães（CC BY 2.0）</p>
<span id="more"></span>

<blockquote>
<p>“征服JavaScript面试”是我所写的一个系列文章，旨在帮助那些应聘中、高级JavaScript开发职位的读者们准备一些常见的面试问题。我自己在实际面试当中也经常会问到这类问题。系列的第一篇文章请参见<a href="http://www.zcfy.cc/article/master-the-javascript-interview-what-is-a-closure-2127.html"><em>“什么是闭包”</em></a>。</p>
</blockquote>
<blockquote>
<p>注：本文均以ES6标准做代码举例。如果想了解ES6，可以参阅<a href="https://medium.com/javascript-scene/how-to-learn-es6-47d9a1ac2620"><em>“ES6学习指南”</em></a>。</p>
</blockquote>
<p>原文链接：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.d84c324od"><em>https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.d84c324od</em></a></p>
<p>对象在JavaScript语言中使用十分广泛，学会如何有效地运用对象，有助于工作效率的提升。而不良的面向对象设计，可能会导致代码工程的失败，更严重的话还会引发<a href="https://medium.com/javascript-scene/inside-the-dev-team-death-spiral-6a7ea255467b"><em>整个公司悲剧</em></a>。</p>
<p>不同于其它大部分语言，JavaScript是基于<strong>原型</strong>的对象系统，而不是基于<strong>类</strong>。遗憾的是，大多数JavaScript开发者对其对象系统理解不到位，或者难以良好地应用，总想按照类的方式使用，其结果将导致代码里的对象使用混乱不堪。所以JavaScript开发者最好对<strong>原型和类</strong>都能有所了解。</p>
<h2 id="类继承和原型继承有何区别？"><a href="#类继承和原型继承有何区别？" class="headerlink" title="类继承和原型继承有何区别？"></a>类继承和原型继承有何区别？</h2><p>这个问题比较复杂，大家有可能会在评论区各抒己见、莫衷一是。因此，列位看官需要打起十二分的精神学习个中差异，并将所学良好地运用到实践当中去。</p>
<p><strong>类继承：可以把类比作一张蓝图，它描绘了被创建对象的属性及特征。</strong>。</p>
<p>众所周知，使用_<code>new</code><em>关键字调用构造函数可以创建类的实例。在ES6中，不用</em><code>class</code><em>关键字也可以实现类继承。像Java语言中类的概念，从技术上来说在JavaScript中并不存在。不过JavaScript借鉴了构造函数的思想。ES6中的</em><code>class</code>_关键字，相当于是建立在构造函数之上的一种封装，其本质依旧是函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Foo</span> <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然JavaScript中的类继承的实现建立在原型继承之上，但是并不意味二者_具有相同的功能：_</p>
<p>JavaScript的类继承使用原型链来连接子类和父类的 <em><code>[[Prototype]]</code>，从而形成代理模式。通常情况下，</em><code>super()</code>_构造函数也会被调用。这种机制，形成了<strong>单一继承结构</strong>，以及<strong>面向对象设计中最紧密的耦合行为</strong>。</p>
<blockquote>
<p>“类之间的继承关系，<strong>导致了子类间的相互关联</strong>，从而形成了——基于层级的分类。”</p>
</blockquote>
<p><strong>原型继承：</strong> **<em>原型是工作对象的实例。</em>**对象直接从其他对象继承属性。</p>
<p>原型继承模式下，对象实例可以由多个对象源所组成。这样就使得继承变得更加灵活且[[Prototype]]代理层级较浅。换言之，<strong>对于基于原型继承的面向对象设计，不会产生层级分类这样的副作用</strong>——这是区别于类继承的关键所在。</p>
<p>对象实例通常由工厂函数或者_<code>Object.create()</code>_来创建，也可以直接使用Object字面定义。</p>
<blockquote>
<p>“<strong>原型是工作对象的实例</strong>。对象直接从其他对象继承属性。”</p>
</blockquote>
<h2 id="为什么搞清楚类继承和原型继承很重要？"><a href="#为什么搞清楚类继承和原型继承很重要？" class="headerlink" title="为什么搞清楚类继承和原型继承很重要？"></a>为什么搞清楚类继承和原型继承很重要？</h2><p>继承，本质上讲是一种代码重用机制——各种对象可以借此来共享代码。如果<strong>代码共享的方式</strong>选择不当，<strong>将会引发很多问题</strong>，如：</p>
<p><strong>使用类继承，会产生父-子对象分类的副作用</strong></p>
<p>这种类继承的层次划分体系，对于新用例将不可避免地出现问题。而且基类的过度派生，也会导致<strong>脆弱基类问题</strong>，其错误将难以修复。事实上，类继承会引发面向对象程序设计领域的诸多问题：</p>
<ul>
<li><p><strong>紧耦合问题</strong>（在面向对象设计中，类继承是耦合最严重的一种设计），紧耦合还会引发另一个问题：</p>
</li>
<li><p><strong>脆弱基类问题</strong></p>
</li>
<li><p><strong>层级僵化问题</strong>（新用例的出现，最终会使所有涉及到的继承层次上都出现问题）</p>
</li>
<li><p><strong>必然重复性问题</strong>（因为层级僵化，为了适应新用例，往往只能复制，而不能修改已有代码）</p>
</li>
<li><p><strong>大猩猩-香蕉问题</strong>（你想要的是一个香蕉，但是最终到的却是一个拿着香蕉的大猩猩，还有整个丛林）</p>
</li>
</ul>
<p>对于这些问题我曾做过深入探讨：“类继承已是明日黄花——探究基于原型的面向对象编程思想”</p>
<blockquote>
<p>“优先选择对象组合而不是类继承。”<br>~先驱四人，<a href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&camp=213733&creative=393185&creativeASIN=0201633612&linkCode=shr&tag=eejs-20&linkId=WMUILDJNIUXY4NSH"><em>《设计模式：可复用面向对象软件之道》</em></a></p>
</blockquote>
<p>里面很好地总结了：</p>
<h3 id="是否所有的继承方式都有问题？"><a href="#是否所有的继承方式都有问题？" class="headerlink" title="是否所有的继承方式都有问题？"></a>是否所有的继承方式都有问题？</h3><p>人们说“优先选择对象组合而不是继承”的时候，其实是要表达“优先选择对象组合而不是类继承”（引用自《设计模式》的原文）。该思想在面向对象设计领域属于普遍共识，因为<strong>类继承方式的先天缺陷</strong>，会导致很多问题。人们在谈到继承的时候，总是习惯性地省略<strong>类</strong>这个字，给人的感觉像是在针对所有的继承方式，而事实上并非如此。</p>
<p>因为大部分的继承方式还是很棒的。</p>
<h2 id="三种不同的原型继承方式"><a href="#三种不同的原型继承方式" class="headerlink" title="三种不同的原型继承方式"></a>三种不同的原型继承方式</h2><p>在深入探讨其他继承类型之前，还需要先仔细分析下我所说的<strong>类继承</strong>。</p>
<p>你可以在Codepen上找到并测试下这段<a href="http://codepen.io/ericelliott/pen/pgdPOb?editors=001"><em>示例程序</em></a>。</p>
<p><em><code>BassAmp</code></em> 继承自 <em><code>GuitarAmp</code></em>, <em><code>ChannelStrip</code></em> 继承自 <em><code>BassAmp</code></em> 和 _<code>GuitarAmp</code>_。从这个例子我们可以看到面向对象设计发生问题的过程。ChannelStrip实际上并不是GuitarAmp的一种，而且它根本不需要一个cabinet的属性。一个比较好的解决办法是创建一个新的基类，供amps和strip来继承，但是这种方法依然有所局限。</p>
<p>到最后，采用新建基类的策略也会失效。</p>
<p>更好的办法就是通过类组合的方式，来继承那些真正需要的属性：</p>
<p><a href="http://codepen.io/ericelliott/pen/XXzadQ?editors=001"><em>修改后的代码</em></a>。</p>
<p>认真看这段代码，你就会发现：通过对象组合，我们可以确切地保证对象可以按需继承。这一点是类继承模式不可能做到的。因为使用类继承的时候，子类会把需要的和不需要的属性统统继承过来。</p>
<p>这时候你可能会问：“唔，是那么回事。可是这里头怎么没提到原型啊？”</p>
<p>客官莫急，且听我一步步道来~首先你要知道，基于原型的面向对象设计方法总共有三种。</p>
<ol>
<li><p><strong>拼接继承：</strong> 是直接从一个对象拷贝属性到另一个对象的模式。被拷贝的原型通常被称为<strong>mixins</strong>。ES6为这个模式提供了一个方便的工具_<code>Object.assign()</code><em>。在ES6之前，一般使用Underscore/Lodash提供的</em><code>.extend()</code>，或者_ jQuery <em>中的<code>$.extend()</code>,</em> 来实现。上面那个对象组合的例子，采用的就是拼接继承的方式。</p>
</li>
<li><p><strong>原型代理：</strong>JavaScript中，一个对象可能包含一个指向原型的引用，该原型被称为<strong>代理</strong>。如果某个属性不存在于当前对象中，就会查找其代理原型。代理原型本身也会有自己的代理原型。这样就形成了一条原型链，沿着代理链向上查找，直到找到该属性，或者找到根代理_<code>Object.prototype</code><em>为止。原型就是这样，通过使用</em><code>new</code><em>关键字来创建实例以及</em><code>Constructor.prototype</code><em>前后勾连成一条继承链。当然，也可以使用</em><code>Object.create()</code>_来达到同样的目的，或者把它和拼接继承混用，从而可以把多个原型精简为单一代理，也可以做到在对象实例创建后继续扩展。</p>
</li>
<li><p><strong>函数继承：</strong>在JavaScript中，任何函数都可以用来创建对象。如果一个函数既不是构造函数，也不是 _<code>class</code>_，它就被称为<strong>工厂函数</strong>。函数继承的工作原理是：由工厂函数创建对象，并向该对象直接添加属性，借此来扩展对象（使用拼接继承）。函数继承的概念最先由道格拉斯·克罗克福德提出，不过这种继承方式在JavaScript中却早已有之。</p>
</li>
</ol>
<p>这时候你会发现，<strong>拼接继承是JavaScript能够实现对象组合的秘诀</strong>，也使得原型代理和函数继承更加丰富多彩。</p>
<p>多数人谈起JavaScript面向对象设计时，首先想到的都是原型代理。不过你看，可不仅仅只有原型代理。要取代类继承，原型代理还是得靠边站，<strong>对象组合才是主角</strong>。</p>
<h2 id="为什么说对象组合能够避免脆弱基类问题"><a href="#为什么说对象组合能够避免脆弱基类问题" class="headerlink" title="为什么说对象组合能够避免脆弱基类问题"></a><strong>为什么说对象组合能够避免脆弱基类问题</strong></h2><p>要搞清楚这个问题，首先要知道脆弱基类是如何形成的：</p>
<ol>
<li><p>假设有基类_<code>A</code>_；</p>
</li>
<li><p>类_<code>B</code><em>继承自基类</em><code>A</code>_；</p>
</li>
<li><p>类_<code>C</code><em>继承自</em><code>B</code>_；</p>
</li>
<li><p>类_<code>D</code><em>也继承自</em><code>B</code>_；</p>
</li>
</ol>
<p>在_<code>C</code><em>中调用</em><code>super</code><em>方法，该方法将执行类</em><code>B</code><em>中的代码。同样，</em><code>B</code><em>也调用</em><code>super</code><em>方法，该方法会执行</em><code>A</code>_中的代码。</p>
<p>_<code>C</code><em>和</em><code>D</code><em>需要从</em><code>A</code><em>、</em><code>B</code><em>中继承一些无关联的特性。此时，</em><code>D</code><em>作为一个新用例，需要从</em><code>A</code><em>的初始化代码继承一些特性，这些特性与</em><code>C</code><em>的略有不同。为了应对以上需求，菜鸟开发人员会去调整</em><code>A</code><em>的初始化代码。于是乎，尽管**</em><code>D</code><em>可以正常工作**，但是</em><code>C</code>_原本的特性被破坏了。</p>
<p><strong>上面这个例子中，_<code>A</code><em>和</em><code>B</code><em>为</em><code>C</code><em>和</em><code>D</code><em>提供各种特性。可是，</em><code>C</code><em>和</em><code>D</code><em>不需要来自</em><code>A</code><em>和</em><code>B</code><em>的所有特性，它们只是需要继承某些属性。但是，通过继承和调用</em><code>super</code>_方法，你无法选择性地继承，只能全部继承：</strong></p>
<blockquote>
<p>“面向对象语言的问题在于，子类会携带有父类所隐含的环境信息。<strong>你想要的是一个香蕉，但是最终到的却是一个拿着香蕉的大猩猩</strong>，以及整个丛林”——乔·阿姆斯特朗<a href="http://www.amazon.com/gp/product/1430219483?ie=UTF8&camp=213733&creative=393185&creativeASIN=1430219483&linkCode=shr&tag=eejs-20&linkId=3MNWRRZU3C4Q4BDN"><em>《编程人生》</em></a></p>
</blockquote>
<p><strong>如果是使用对象组合的方式</strong><br>设想有如下几个特性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">feat1, feat2, feat3, feat4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><code>C</code><em>需要特性</em><code>feat1</code></em> 和 <em><code>feat3</code><em>，而</em><code>D</code></em> 需要特性_<code>feat1</code>, <code>feat2</code>, <code>feat4</code>_：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> C = <span class="title function_">compose</span>(feat1, feat3);</span><br><span class="line"><span class="keyword">const</span> D = <span class="title function_">compose</span>(feat1, feat2, feat4);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假如你发现_<code>D</code><em>需要的特性与</em><code>feat1</code><em><strong>略有出入</strong>。这时候无需改动</em><code>feat1</code><em>，**只要创建一个</em><code>feat1</code><em>的定制化版本**，就可以做到保持</em><code>feat2</code><em>和</em><code>feat4</code><em>特性的同时，也不会影响到</em><code>C</code>_，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> D = <span class="title function_">compose</span>(custom1, feat2, feat4);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>像这样灵活的优点，是类继承方式所不具备的。因为<strong>子类在继承的时候，会连带着整个类继承结构</strong>。</p>
<p>这种情况下，要适应新的用例，要么复制现有类层划分（必然重复性问题），要么在现有类层结构的基础上进行重构，就又会导致<strong>脆弱基类问题</strong>。</p>
<p>而采用对象组合的话，这两个问题都将迎刃而解。</p>
<h3 id="你真的了解原型了吗？"><a href="#你真的了解原型了吗？" class="headerlink" title="你真的了解原型了吗？"></a>你真的了解原型了吗？</h3><p>采用先创建类和构造函数，然后再继承的方式，并不是<strong>正宗的原型继承</strong>，不过是<strong>使用原型来模拟类继承</strong>的方法罢了。这里有一些关于<a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a#.khem2m91q"><em>JavaScript中关于继承的常见误解</em></a>，供君参考。</p>
<p>JavaScript中，类继承模式历史悠久，而且建立在灵活丰富的原型继承特性之上（ES6以上的版本亦然）。可是一旦使用了类继承，就再也享受不到原型灵活强大的特性了。<strong>类继承的所有问题都将始终如影随形无法摆脱</strong>。</p>
<blockquote>
<p>在JavaScript中使用类继承，是一种舍本逐末的行为。</p>
</blockquote>
<h3 id="Stamps：可组合式工厂函数"><a href="#Stamps：可组合式工厂函数" class="headerlink" title="Stamps：可组合式工厂函数"></a>Stamps：可组合式工厂函数</h3><p>多数情况下，对象组合是通过使用工厂函数来实现：工厂函数负责创建对象实例。如果工厂函数也可以组合呢？快查看<a href="https://github.com/stampit-org/stamp-specification"><em>Stamp文档</em></a>找出答案吧。</p>
<blockquote>
<p><em>（译者注：感觉原文表达有些不尽兴。于是我自作主张地画了2个图便于读者理解。不足之处还请谅解和指正）</em><br><img src="http://p0.qhimg.com/t0178c2bc72eeecf1c2.png"><br>图：类继承</p>
</blockquote>
<blockquote>
<p><em>说明：从图上可以直接看出单一继承关系、紧耦合以及层级分类的问题；其中，类8，只想继承五边形的属性，却得到了继承链上其它并不需要的属性——大猩猩/香蕉问题；类9只需要把五角星属性修改成四角形，导致需要修改基类1，从而影响整个继承树——脆弱基类/层级僵化问题；否则就需要为9新建基类——必然重复性问题。</em><br><img src="http://p0.qhimg.com/t0115714d671a900a07.gif"><br>图：原型继承/对象组合</p>
</blockquote>
<blockquote>
<p><em>说明：采用原型继承/对象组合，可以避免复杂纵深的层级关系。当1需要四角星特性的时候，只需要组合新的特性即可，不会影响到其他实例。</em></p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>继承</tag>
        <tag>类</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.JS 内存控制</title>
    <url>/2017/06/07/node/Node-JS%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>笔记部分内容摘自 《深入浅出 Node.JS》 —— 朴灵</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一方面由于Node基于无阻塞、事件驱动，具有内存消耗低的特点，常用于开发高网络请求的应用，因此，在服务器端，需要对资源进行高效利用。另一方面node选择了V8，享受着V8带来的良好性能与语言特性，但是也受到了V8的一些限制。<br>如Node通过JS生成对象，V8会在内存中回收不再被使用的垃圾内存，一方面减少了内存管理的负担，但是另一方面也造成了内存管理上的不灵活，如V8在内存上有大小限制，32位系统上限制为0.7G，64位系统为1.4G，在应用中，若不小心触碰到这个极限值，会造成进程退出，并且在进行垃圾回收的过程中，会导致阻塞代码，程序暂停。</p>
<blockquote>
<p>这篇笔记，只是大致了解node里内存的控制、清理机制，具体如何使用、排查解决内存问题未做详细记录。</p>
</blockquote>
<span id="more"></span>

<h1 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h1><h2 id="内存分代"><a href="#内存分代" class="headerlink" title="内存分代"></a>内存分代</h2><p>在V8中，所有的对象通过堆进行分配。</p>
<p><img src="/img/%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6_1.png" alt="V8堆示意图"></p>
<blockquote>
<p>当我们声明变量并赋值时，程序会在堆中寻找空闲区分配内存，如果已经申请的堆空闲区已经不够分配新的对象，则继续申请堆内存，直到堆的大小超过V8的限制。</p>
</blockquote>
<p>在V8中，将内存分为新生（年轻）代以及老生（年老）代两种，进行分别控制。</p>
<p><strong>新生代</strong>：存活事件较短的对象</p>
<p><strong>老生代</strong>：存活时间较长或长期驻内存的对象。</p>
<p><img src="/img/%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6_2.png" alt="V8分代示意图"></p>
<p>如图所示，在V8的控制下，新生内存占较少的一部分，老生空间则占据了大部分堆空间。默认情况下，新生内存空间在64位和32位系统上分别占据32MB和16MB大小，而老生内存空间在64位和32位系统上分别占据1400MB和700MB大小。</p>
<p><strong>但是，V8堆内存最大保留空间的配置代码，则是如下定义的：</strong></p>
<blockquote>
<p>The young generation consists of two semi spaces and we reserve twice the amount needed for those in order to ensure the new space can be aligned to its size</p>
</blockquote>
<p><strong>由此，年轻一代的堆内存空间是两倍的配置</strong></p>
<p>可以手动设置，以使用更多的内存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --max-old-space-size=1700 test.js //单位MB, 设置老生内存</span><br><span class="line"></span><br><span class="line">$ node --max-new-space-size=1024 test.js //单位kb, 设置新生内存</span><br></pre></td></tr></table></figure>

<p><br/><br/></p>
<h2 id="Scavenge-算法"><a href="#Scavenge-算法" class="headerlink" title="Scavenge 算法"></a>Scavenge 算法</h2><p><strong>Scavenge 算法主要用于新生代的垃圾回收</strong>，此算法采用的是一种<strong>复制</strong>的方式实现的垃圾回收算法。</p>
<p>前面说了新生代的堆内存空间由两部分组成，分为正在使用中的堆内存空间，称为<strong>From空间</strong>，以及闲置的堆内存空间，称为<strong>To空间</strong>。顾名思义，Scavenge 算法正是一种在这两个空间中将仍存活的对象复制到闲置储存空间后释放原储存空间的方式。</p>
<p><strong>过程：当分配对象时，显示在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存存活对象占用的空间会被释放，完成复制后，对换From空间和To空间，到此垃圾回收完成。</strong></p>
<p>值得注意的是，如果一个对象经过多次复制依然存活，则会将此对象生存周期较长的对象，并移动到老生堆空间中，以采用其他算法进行管理，此过程称为对象的晋升。另外，当To空间使用占比已经超过限制，也会将新代对象直接移动到老生对象空间。</p>
<p><strong>由于 Scavenge 算法将内存对象在两个空间中复制交换，因此，只能使用堆内存的一半空间，以牺牲空间换效率。 此算法也正因此，适合应用在新生代中，因为新生代的生命周期段，占用空间也较少。</strong></p>
<p><br/><br/></p>
<h2 id="Mark-Sweep-amp-Mark-Compact"><a href="#Mark-Sweep-amp-Mark-Compact" class="headerlink" title="Mark-Sweep &amp; Mark-Compact"></a>Mark-Sweep &amp; Mark-Compact</h2><p>大致了解了新生代的垃圾回收算法，下面了解下老生代的垃圾回收机制。</p>
<br/>

<h3 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h3><p>标记清除算法，通过一次遍历老生代对象，对所有还活着的对象进行标记，在遍历完成后实施清除，将所有未标记的对象清除。</p>
<p>但是这种算法的问题也是显而易见的，在一次操作后，会造成内存空间的不连续状态，也就是内存碎片。这种情况下，当有一个稍大的对象要放入老生代空间中时，可能由于空间过于碎片化，而导致无法找到一块适合其大小的空间存放，便会造成又一次的垃圾回收，以期待回收出一块适合的区域存放该对象。由此，提出里另一个算法 Mark-Compact。</p>
<br/>

<h3 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h3><p>此算法是在 Mark-Sweep 的基础上改进而来的，差别在于对象在标记为死亡后，在整理的过程中，将或者的对象向一端移动，移动完成后，直接清理掉边界外的内存，这样就不会出现内存碎片的问题了。</p>
<p><strong>在V8中，这两种回收策略并不是单独使用的，而是结合使用的</strong></p>
<p><strong>V8主要使用Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才使用Mark-Compact。</strong></p>
<br/>

<h3 id="Incremental-Marking"><a href="#Incremental-Marking" class="headerlink" title="Incremental Marking"></a>Incremental Marking</h3><p><strong>增量标记</strong></p>
<blockquote>
<p>为了避免出现 JS 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的 3 种基本算法都需要将应用逻辑暂停下来，这种暂停成为 “全停顿”。V8 老生代通常配置得很大，且存活对象较多，全堆垃圾回收的各种动作造成的停顿会比较可怕，需要设法改善。V8 先从标记阶段入手，将原本一口气停顿完成的动作改为增量标记，也就是拆分为许多小 “步进”，没做完一步就让 JS 应用逻辑执行一小会儿。这种垃圾回收与应用逻辑交替执行直到标记完成，可以让最大停顿时间减少 5 倍左右。</p>
</blockquote>
<h1 id="关于使用内存"><a href="#关于使用内存" class="headerlink" title="关于使用内存"></a>关于使用内存</h1><p>参考《深入浅出NodeJS》一书的相关内容，主要说明了作用域及闭包等的使用，我觉得这些问题不如直接使用ES6的相关特性解决更加简单有效，还不容易让自己出错。所以这里就不再做繁琐的记录了。</p>
<h1 id="关注内存与缓存"><a href="#关注内存与缓存" class="headerlink" title="关注内存与缓存"></a>关注内存与缓存</h1><blockquote>
<p>勿将内存当做缓存使用。</p>
</blockquote>
<ol>
<li>缓存限制（可使用现有的相关模块）、提供清空缓存队列的接口。</li>
<li>使用redis、Memcached</li>
</ol>
<h1 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h1><p>使用相关模块：node-heapdump/node-memwatch </p>
<p><em>说实话，我感觉以我现在的能力，我觉得我根本不会考虑到内存泄漏、检查等之类的问题→_→<br>所以暂时简单记录，以后如果需要的话，再详细补充</em></p>
<p><br/><br/></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>NodejS</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer</title>
    <url>/2017/07/04/node/buffer/</url>
    <content><![CDATA[<blockquote>
<p>笔记部分内容摘自 《深入浅出 Node.JS》 —— 朴灵</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>与前端不同，前端常常只需要处理简单字符串操作及DOM操作，而后端需要处理相对复杂的文件、网络I/O等，JS自由的字符串无法满足需求，于是有了buffer以满足后端的需求。</p>
<span id="more"></span>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><ul>
<li>buffer是JS与C++结合的一个模块，性能相关以C++实现，非性能相关以JS实现。</li>
<li>buffer由于是C++实现的内建模块，其在node项目进程启动时就已加载进内存，使用时无需require。</li>
<li>buffer所使用的内存为堆外内存，非V8分配，而是node在C++层面申请，在使用时node再进行分配。</li>
<li>buffer对象类似于Array，形如&lt;Buffer d3 e2 cd 67 2b 21 8c 9a e7 20 1f 2e 7c 6d 4a cf 3c&gt;，其元素皆为16进程两位数。</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf.<span class="property">length</span>); <span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p><strong>采用slab分配机制</strong></p>
<p>slab就是一块申请好的固定大小的内存区域</p>
<p>具有三种状态：</p>
<ul>
<li>full：完全分配状态</li>
<li>partial：部分分配状态</li>
<li>empty：没有被分配状态</li>
</ul>
<p>slab以8k为界限，区分buffer是大对象还是小对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Buffer</span>.<span class="property">poolSize</span> = <span class="number">8</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<h2 id="分配小对象-（-lt-8kb的buffer）"><a href="#分配小对象-（-lt-8kb的buffer）" class="headerlink" title="分配小对象 （&lt;=8kb的buffer）"></a>分配小对象 （&lt;=8kb的buffer）</h2><p>使用局部变量pool作为中间处理对象，处于分配状态的slab都指向该变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">allocPool</span>(<span class="params"></span>) &#123;</span><br><span class="line">  pool = <span class="keyword">new</span> <span class="title class_">SlowBuffer</span>(<span class="title class_">Buffer</span>.<span class="property">poolSize</span>);</span><br><span class="line">  pool.<span class="property">used</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分配buffer对象会先检查是否有pool对象，若没有，则通过创建新的slab对象单元，并指向它。</li>
<li>然后记录下使用的大小used，及此slab使用的偏移量offset。</li>
<li>再次创建buffer会判断此slab单元是否足够存放，够则继续存放，不够则重新创建新的slab单元以存储。</li>
<li>当slab单元不够存放，重新创建单元时，旧的slab单元则会造成浪费。</li>
</ul>
<p><strong>一个slab单元内所有的buffer小对象全部都已经释放并可以回收时，才能释放此slab单元。<br>即若一个slab单元中只存放了1个字节的buffer对象，也会造成整个8kb的slab单元内存无法释放。</strong></p>
<h2 id="分配大对象-（-gt-8kb的buffer）"><a href="#分配大对象-（-gt-8kb的buffer）" class="headerlink" title="分配大对象 （&gt;8kb的buffer）"></a>分配大对象 （&gt;8kb的buffer）</h2><p>直接分配一个指定大小(大对象大小)的内存空间：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">parent</span> = <span class="keyword">new</span> <span class="title class_">SlowBuffer</span>(<span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">offset</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里的slab分配机制，旨在于减少系统调用，以提升性能。不过对于平时的开发来说，我暂时没看出来有什么作用，算是顶多更加深入的了解了buffer。</p>
<h1 id="Buffer的转换"><a href="#Buffer的转换" class="headerlink" title="Buffer的转换"></a>Buffer的转换</h1><p>支持的转换编码类型：</p>
<ul>
<li>ASCII</li>
<li>UTF-8</li>
<li>UTF-16LE/UCS-2</li>
<li>Base64</li>
<li>Binary</li>
<li>Hex</li>
</ul>
<h2 id="字符串转Buffer"><a href="#字符串转Buffer" class="headerlink" title="字符串转Buffer"></a>字符串转Buffer</h2><p>** 方式： ** 通过<strong>构造函数</strong>转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="title class_">Buffer</span>(str, [encoding]);</span><br></pre></td></tr></table></figure>

<p><code>encoding</code>为可选参数，默认值为<code>UTF-8</code>。</p>
<p><strong>一个</strong>Buffer对象即可以存储<strong>多种</strong>编码类型的字符串转码，通过<code>write()</code>方法实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buf.<span class="title function_">write</span>(string, [offset], [length], [encoding]);</span><br></pre></td></tr></table></figure>

<p><strong>这种存储多种编码类型转码的Buffer，由于每种编码所有的字节长度不同，再解码转回普通字符串时需要格外谨慎小心！</strong></p>
<h2 id="Buffer转字符串"><a href="#Buffer转字符串" class="headerlink" title="Buffer转字符串"></a>Buffer转字符串</h2><p><strong>方式：</strong> <code>toString()</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buf.<span class="title function_">toString</span>([encoding], [start], [end]);</span><br></pre></td></tr></table></figure>

<p><code>encoding</code>默认<code>UTF-8</code></p>
<h2 id="不支持编码类型的相互转换"><a href="#不支持编码类型的相互转换" class="headerlink" title="不支持编码类型的相互转换"></a>不支持编码类型的相互转换</h2><p>由于Buffer对象支持的编码类型有限，所以借助其它具有相似功能的模块可以更好的完成Buffer的转换。</p>
<ul>
<li>iconv : <a href="https://www.npmjs.com/package/iconv">https://www.npmjs.com/package/iconv</a></li>
<li>iconv-lite (推荐) :  <a href="https://www.npmjs.com/package/iconv-lite">https://www.npmjs.com/package/iconv-lite</a></li>
</ul>
<h1 id="Buffer拼接"><a href="#Buffer拼接" class="headerlink" title="Buffer拼接"></a>Buffer拼接</h1><h2 id="不正确（危险）的Buffer拼接方式"><a href="#不正确（危险）的Buffer拼接方式" class="headerlink" title="不正确（危险）的Buffer拼接方式"></a>不正确（危险）的Buffer拼接方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;test.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">    data += chunk;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li><code>data += chunk;</code> 隐含着buffer转换： <code>data = data.toString() +chunk.toString();</code></li>
<li>当出现宽字节编码，可能会出现乱码问题。</li>
<li>在处理UTF-8、Base64或UCS-2/UTF-16LE这三种编码时可以采用添加一条语句来解决此问题：<code>rs.setEncoding(encoding)</code></li>
</ul>
<h2 id="正确的拼接Buffer"><a href="#正确的拼接Buffer" class="headerlink" title="正确的拼接Buffer"></a>正确的拼接Buffer</h2><p><strong>思路：</strong> 拼接Buffer对象，再用iconv-lite等转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chunks = [];</span><br><span class="line"><span class="keyword">let</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line">    size += chunk.<span class="property">length</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks, size);</span><br><span class="line">    <span class="keyword">let</span> str = iconv.<span class="title function_">decode</span>(buf, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中值得一看的是<code>Buffer.concat()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Buffer</span>.<span class="property">concat</span> = <span class="keyword">function</span>(<span class="params">list, length</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(list)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Usage: Buffer.concat(list, [length])&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (list.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> length !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      length = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">          <span class="keyword">let</span> buf = list[i];</span><br><span class="line">          length += buf.<span class="property">length</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">Buffer</span>(length);</span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">let</span> buf = list[i];</span><br><span class="line">      buf.<span class="title function_">copy</span>(buffer, pos);</span><br><span class="line">      pos += buf.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用Buffer提升性能"><a href="#用Buffer提升性能" class="headerlink" title="用Buffer提升性能"></a>用Buffer提升性能</h1><ul>
<li>在web应用中，逻辑代码的编写过程中，通常是在操作字符串，但一旦通过网络传输，都需要进行Buffer转换，以进行二进制数据传输。</li>
<li>在不需要改动读取的文件内容的前提下，可以直接读取Buffer并进行传输，尽量减少转换。</li>
</ul>
<p></br></br></br></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Event Loop</title>
    <url>/2017/07/21/node/eventLoop/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://youtu.be/8aGhZQkoFbQ">Philip Roberts: What the heck is the event loop anyway? | JSConf EU 2014</a></p>
</blockquote>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8aGhZQkoFbQ" frameborder="0" allowfullscreen></iframe>

<span id="more"></span>

<hr>
<p>下面的文章基本是对视频的整理，看完视频可以直接从文章<a href="./#Node-js%E7%9A%84Event-Loop">Node.js的Event Loop</a>这一节开始看。</p>
<div class="note danger"><p><a href="http://blog.csdn.net/lin_credible/article/details/40143961">朴灵对下面文章的评注</a> </p>
</div>

<hr>
<h1 id="【转】JavaScript-运行机制详解：再谈Event-Loop"><a href="#【转】JavaScript-运行机制详解：再谈Event-Loop" class="headerlink" title="【转】JavaScript 运行机制详解：再谈Event Loop"></a>【转】JavaScript 运行机制详解：再谈Event Loop</h1><br>

<blockquote>
<p>转载自 <a href="http://www.ruanyifeng.com/">阮一峰</a>：<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></p>
</blockquote>
<p>一年前，我写了一篇<a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《什么是 Event Loop？》</a>，谈了我对Event Loop的理解。</p>
<p>上个月，我偶然看到了Philip Roberts的演讲<a href="http://vimeo.com/96425312">《Help, I’m stuck in an event-loop》</a>。这才尴尬地发现，自己的理解是错的。我决定重写这个题目，详细、完整、正确地描述JavaScript引擎的内部运行机制。下面就是我的重写。</p>
<h2 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h2><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<p>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</p>
<p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>
<p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<ol>
<li><p>所有同步任务都在主线程上执行，形成一个<a href="http://www.ruanyifeng.com/blog/2013/11/stack.html">执行栈</a>（execution context stack）。</p>
</li>
<li><p>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
</li>
<li><p>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
</li>
<li><p>主线程不断重复上面的第三步。</p>
</li>
</ol>
<p>下图就是主线程和任务队列的示意图。</p>
<p><img src="http://image.beekka.com/blog/2014/bg2014100801.jpg" alt="任务队列"></p>
<p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。</p>
<h2 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h2><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p>
<p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>
<p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<p>为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲<a href="http://vimeo.com/96425312">《Help, I’m stuck in an event-loop》</a>）。</p>
<p><img src="http://image.beekka.com/blog/2014/bg2014100802.png" alt="Event Loop"></p>
<p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。</p>
<p>执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">req.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">req.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br><span class="line">req.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br><span class="line">req.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">req.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">req.<span class="title function_">send</span>();</span><br><span class="line">req.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br><span class="line">req.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。</p>
<p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。</p>
<p>setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。</p>
<p>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。</p>
<p>总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>
<p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p>
<p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>
<h2 id="Node-js的Event-Loop"><a href="#Node-js的Event-Loop" class="headerlink" title="Node.js的Event Loop"></a>Node.js的Event Loop</h2><p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>
<p>请看下面的示意图（作者<a href="https://twitter.com/BusyRich/status/494959181871316992">@BusyRich</a>）。</p>
<p><img src="http://image.beekka.com/blog/2014/bg2014100803.png" alt="Node.js"></p>
<p>根据上图，Node.js的运行机制如下。</p>
<p>（1）V8引擎解析JavaScript脚本。</p>
<p>（2）解析后的代码，调用Node API。</p>
<p>（3）<a href="https://github.com/joyent/libuv">libuv库</a>负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</p>
<p>（4）V8引擎再将结果返回给用户。</p>
<p>除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：<a href="http://nodejs.org/docs/latest/api/process.html#process_process_nexttick_callback">process.nextTick</a>和<a href="http://nodejs.org/docs/latest/api/timers.html#timers_setimmediate_callback_arg">setImmediate</a>。它们可以帮助我们加深对”任务队列”的理解。*(这里的内容可以参考 朴灵——《深入浅出NodeJS》第60页)*</p>
<p>process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。请看下面的例子（via <a href="http://stackoverflow.com/questions/17502948/nexttick-vs-setimmediate-visual-explanation">StackOverflow</a>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;TIMEOUT FIRED&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// TIMEOUT FIRED</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。</p>
<p>现在，再看setImmediate。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;TIMEOUT FIRED&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1–TIMEOUT FIRED–2，也可能是TIMEOUT FIRED–1–2。</p>
<p>令人困惑的是，Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setImmediate</span>(<span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;TIMEOUT FIRED&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// TIMEOUT FIRED</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，setImmediate和setTimeout被封装在一个setImmediate里面，它的运行结果总是1–TIMEOUT FIRED–2，这时函数A一定在timeout前面触发。至于2排在TIMEOUT FIRED的后面（即函数B在timeout后面触发），是因为setImmediate总是将事件注册到下一轮Event Loop，所以函数A和timeout是在同一轮Loop执行，而函数B在下一轮Loop执行。</p>
<p>我们由此得到了process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  process.<span class="title function_">nextTick</span>(foo);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>事实上，现在要是你写出递归的process.nextTick，Node.js会抛出一个警告，要求你改成setImmediate。</p>
<p>另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js-call-apply-bind</title>
    <url>/2017/09/07/node/js-call-apply-bind/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
call/apply/bind 总体上都是改变调用对象的this指向。
</blockquote>

<span id="more"></span>

<h1 id="apply-call"><a href="#apply-call" class="headerlink" title="apply()/call()"></a>apply()/call()</h1><p>apply()/call()类似，差别只在给函数传入参数的方式不一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.<span class="title function_">call</span>(thisArg[, arg1[, arg2[, arg3[, ...]]]]);</span><br><span class="line"></span><br><span class="line">fun.<span class="title function_">apply</span>(thisArg, args);</span><br></pre></td></tr></table></figure>

<p>apply()方法第二参数也可以支持类数组对象。</p>
<h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.<span class="title function_">bind</span>(thisArg[, arg1[, arg2[, ...]]]);</span><br></pre></td></tr></table></figure>

<p>bind() 方法不同在于</p>
<ol>
<li>通过bind修改了this指向后返回原函数拷贝，并不会默认执行。</li>
<li>参数可以执行时再添加，参数按照形参顺序依次读入。</li>
<li>bind第一个参数指定this指向，该参数不能被重写，即只能被绑定一次。</li>
</ol>
<h1 id="详细用法"><a href="#详细用法" class="headerlink" title="详细用法"></a>详细用法</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a></p>
<br>
<br>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的this</title>
    <url>/2017/09/06/node/js-this/</url>
    <content><![CDATA[<p>this指向相关问题</p>
<span id="more"></span>

<h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">MDN This</a></p>
<p><a href="http://www.cnblogs.com/pssp/p/5216085.html">彻底理解 js 中 this 的指向，不必硬背。</a></p>
<h2 id="简单整理"><a href="#简单整理" class="headerlink" title="简单整理"></a>简单整理</h2><p><strong>只是简单整理，不严谨，学习还是看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">MDN</a>官方文档</strong></p>
<ul>
<li>绝大多数情况下，函数的调用方式决定了<code>this</code>的值。</li>
<li>绝大多数情况下，<code>this</code>的指向在函数定义时不能确定，在函数执行时确定。</li>
<li>绝大多数情况下，<code>this</code>指向调用它的对象。</li>
<li>全局情况下，<code>this</code>指window，nodeJS下指向<code>global</code>。</li>
<li>全局情况下，严格模式时<code>this</code>指向<code>undefined</code>。</li>
<li>调用时，可以通过<code>call()/apply()</code>方法间接调用以改变上下文。</li>
<li>可以使用<code>bind()</code>永久绑定其指向到第一个参数，无论这个函数时如何调用的。且bind只生效一次。</li>
<li>一个含有<code>this</code>的函数被多级调用，<code>this</code>也只指向直接调用它的上一级对象，而不是最外层。</li>
<li>特殊情况，通过ES6箭头函数捕获其所在上下文的<code>this</code>值，作为自己的<code>this</code>值。</li>
<li>箭头函数下this会忽略严格模式下的相关规则。</li>
<li>箭头函数中的<code>this</code>指向不会因为<code>call()/apply()/bind()</code>方法改变。</li>
</ul>
</br>
</br>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ES6：let&amp;const</title>
    <url>/2017/07/18/node/let-and-const/</url>
    <content><![CDATA[<blockquote>
<p>参考 <a href="http://es6.ruanyifeng.com/">阮一峰 《ES6 标准入门》</a> </p>
</blockquote>
<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><ul>
<li>块级作用域：在ES5及以前，JS只有全局作用域及函数作用域，<code>let</code>则为JS提供了<strong>块级作用域</strong>。</li>
<li>变量提升：<code>let</code>声明的变量<strong>不会提升</strong>。</li>
<li>锁区：<code>let</code>声明的变量会暂时<strong>锁定</strong>其存在的作用域。</li>
<li>不允许重复声明：<code>let</code>声明的变量只能在声明<strong>之后</strong>使用且<strong>不允许重复声明</strong>。</li>
</ul>
<span id="more"></span>

<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><blockquote>
<p><a href="http://www.bilibili.com/video/av6698380/index_1.html">http://www.bilibili.com/video/av6698380/index_1.html</a></p>
</blockquote>
<p><embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=6698380&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></embed></p>
<br>

<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="简要说明-1"><a href="#简要说明-1" class="headerlink" title="简要说明"></a>简要说明</h2><ul>
<li>声明全局变量，必须<strong>初始化</strong>。</li>
<li>全局变量在其作用于下有效，同样不会变量提升，<strong>不能重新赋值</strong>。</li>
</ul>
<p><strong>常量不变，不能重新赋值是指常量本身的值（对简单变量来说，如<code>string</code>、<code>boolean</code>等，值不变，对于引用类型来说是引用指向不变）不能改变。<br>引用类型指向的对象里的属性可以改变值。</strong></p>
<h2 id="视频-1"><a href="#视频-1" class="headerlink" title="视频"></a>视频</h2><blockquote>
<p><a href="http://www.bilibili.com/video/av6698380/index_2.html">http://www.bilibili.com/video/av6698380/index_2.html</a></p>
</blockquote>
<p><embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=6698380&page=2" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></embed></p>
<p><br><br></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>nodejs</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 简单知识</title>
    <url>/2017/05/24/node/nodeJS/</url>
    <content><![CDATA[<h1 id="下载及安装"><a href="#下载及安装" class="headerlink" title="下载及安装"></a>下载及安装</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul>
<li>直接在<a href="https://nodejs.org/en/">Nodejs官网</a>下载安装 (简单) </li>
<li>版本推荐6.10+,暂可不用下载最新版本v7</li>
</ul>
<h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><p>CMD 下输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>可以正常显示相应的版本即为安装成功</p>
<p>若失败,检查系统环境变量PATH是否已配置了Nodejs</p>
<p>未添加可手动添加</p>
<span id="more"></span>

<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">//这种方法安装的版本一般比较低,很多包会用不了</span><br></pre></td></tr></table></figure>

<p><a href="https://nodejs.org/en/download/package-manager/">官方教程</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//若安装 5.x 版本是：</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_5.x | bash - </span><br><span class="line">apt-get install nodejs -y</span><br><span class="line"></span><br><span class="line">//想要安装 6.x 版本就是</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_6.x | bash - </span><br><span class="line">apt-get install nodejs -y</span><br><span class="line"></span><br><span class="line">//如此一来，安装出来的版本就是最新的，npm 也是最新</span><br></pre></td></tr></table></figure>

<h3 id="centOS"><a href="#centOS" class="headerlink" title="centOS"></a>centOS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install nodejs</span><br></pre></td></tr></table></figure>

<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><ul>
<li>较麻烦, 但是好处多. 不介绍, 以后自学.</li>
</ul>
<h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p><strong>webStorm / VScode</strong></p>
<p><em>webStorm 可学生认证,免费使用</em></p>
<h1 id="创建第一个应用"><a href="#创建第一个应用" class="headerlink" title="创建第一个应用"></a>创建第一个应用</h1><h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><p>使用 <code>require</code> 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&quot;http&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line"></span><br><span class="line">	// 发送 HTTP 头部 </span><br><span class="line">	// HTTP 状态值: 200 : OK</span><br><span class="line">	// 内容类型: text/plain</span><br><span class="line">	response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">	// 发送响应数据 &quot;Hello World&quot;</span><br><span class="line">	response.end(&#x27;Hello World\n&#x27;);</span><br><span class="line">&#125;).listen(8888);</span><br><span class="line"></span><br><span class="line">// 终端打印如下信息</span><br><span class="line">console.log(&#x27;Server running at http://127.0.0.1:8888/&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node server.js</span><br><span class="line">Server running at http://127.0.0.1:8888/</span><br></pre></td></tr></table></figure>

<h1 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h1><p><strong>NPM</strong> <em>Node Package Manager</em></p>
<p>NPM 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ol>
<li><strong>允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。</strong></li>
<li>允许用户从 NPM 服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。</li>
</ol>
<h2 id="NPM-常用命令"><a href="#NPM-常用命令" class="headerlink" title="NPM 常用命令"></a>NPM 常用命令</h2><ul>
<li>npm install <package> [-g]</li>
<li>npm help <command></li>
<li>npm update <package> [-g]</li>
</ul>
<h3 id="改用淘宝npm镜像"><a href="#改用淘宝npm镜像" class="headerlink" title="改用淘宝npm镜像"></a>改用<a href="https://npm.taobao.org/">淘宝npm</a>镜像</h3><blockquote>
<p>国内直接使用 npm 官方镜像速度非常慢，推荐使用淘宝 NPM 镜像。<br>淘宝 NPM 镜像是一个完整 npm 镜像，可以用此代替官方版本，同步频率目前为 10 分钟 一次以保证尽量与官方服务同步。</p>
</blockquote>
<h4 id="替换方式"><a href="#替换方式" class="headerlink" title="替换方式"></a>替换方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>同 npm 一样, 除了<code>publish</code>命令, 其他命令都可直接使用.<br>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install [package]</span><br></pre></td></tr></table></figure>

<h2 id="如何找包"><a href="#如何找包" class="headerlink" title="如何找包"></a>如何找包</h2><ul>
<li><a href="https://github.com/">GitHub</a></li>
<li><a href="https://www.npmjs.com/">npm package 官方网站</a></li>
<li>npm search [package]</li>
</ul>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>记录项目相关的基本信息、组件依赖信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;SFMS&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node ./bin/www&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git@127.0.0.1:bitzo/SFMS.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;SFMS&quot;,</span><br><span class="line">    &quot;Manage System&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;bitzo&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http://127.0.0.1:1320/bitzo/SFMS&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;async&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;body-parser&quot;: &quot;~1.15.2&quot;,</span><br><span class="line">    &quot;cookie-parser&quot;: &quot;~1.4.3&quot;,</span><br><span class="line">    &quot;excel-export&quot;: &quot;^0.5.1&quot;,</span><br><span class="line">    &quot;express&quot;: &quot;~4.14.0&quot;,</span><br><span class="line">    &quot;express-session&quot;: &quot;~1.14.2&quot;,</span><br><span class="line">    &quot;formidable&quot;: &quot;^1.1.1&quot;,</span><br><span class="line">    &quot;jade&quot;: &quot;~1.11.0&quot;,</span><br><span class="line">    &quot;jwt-simple&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;log4js&quot;: &quot;1.0.1&quot;,</span><br><span class="line">    &quot;mocha&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;moment&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;mysql&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;node-schedule&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">    &quot;redis&quot;: &quot;^2.6.3&quot;,</span><br><span class="line">    &quot;sha1&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;should&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;superagent&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;supertest&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;validator&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;xml2js&quot;: &quot;*&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尝试写一个简单的服务"><a href="#尝试写一个简单的服务" class="headerlink" title="尝试写一个简单的服务"></a>尝试写一个简单的服务</h2><p>……</p>
<h1 id="nodeJS-常用官方模块"><a href="#nodeJS-常用官方模块" class="headerlink" title="nodeJS 常用官方模块"></a>nodeJS 常用官方模块</h1><p><code>Buffer</code>、<code>Console</code>、<code>Crypto</code>、<code>Event</code>、<code>File System</code></p>
<p><code>HTTP</code>、<code>Module</code>、<code>stream</code>、<code>Path</code>、<code>Query String</code>、<code>URL</code></p>
<p>查看相关的 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/">官方文档</a> 学习</p>
<h1 id="学习-Express-框架"><a href="#学习-Express-框架" class="headerlink" title="学习 Express 框架"></a>学习 Express 框架</h1><p><a href="http://expressjs.com/zh-cn/">Express 官网: 学习入门/大致了解API</a></p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul>
<li><a href="https://github.com/nswbmw/N-blog">GitHub</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000">廖雪峰官网教程</a></li>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/">Node 官网API文档</a></li>
<li><a href="http://www.runoob.com/nodejs/nodejs-tutorial.html">菜鸟教程</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>nodeJS后端文件接收与处理</title>
    <url>/2017/07/10/node/nodeJS%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>参考：<a href="http://blog.csdn.net/bugall/article/details/44873651">nodejs 对 form 表单上传文件数据的解析过程</a></p>
</blockquote>
<p>我是给这东西跪了。。。</p>
<span id="more"></span>

<p>对包体解析，处理数据，拆分数据，整理数据。终于将文件数据和其他参数分离且存好了。</p>
<p>本来觉得一切完美，结果文件这块似乎不能把<code>Buffer</code>转成<code>String</code>存储</p>
<p>最后还是利用了 <a href="https://github.com/felixge/node-formidable">Node-formidable</a> 这个组件。。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">formupload</span> = <span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> form = <span class="keyword">new</span> formidable.<span class="title class_">IncomingForm</span>();</span><br><span class="line">    <span class="keyword">let</span> uploadDir = path.<span class="title function_">normalize</span>(__dirname+<span class="string">&#x27;/&#x27;</span>+<span class="string">&quot;../avatar&quot;</span>);</span><br><span class="line">    form.<span class="property">uploadDir</span> = uploadDir;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(uploadDir);</span><br><span class="line">    form.<span class="title function_">parse</span>(req, <span class="keyword">function</span>(<span class="params">err, fields, files</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> files)&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 处理文件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="title function_">inspect</span>(&#123;<span class="attr">fields</span>: fields, <span class="attr">files</span>: files&#125;));</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还找到一段源码，是直接操作buffer的，可以参考。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> chunks = [],</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span> , <span class="keyword">function</span>(<span class="params">chunk</span>)&#123;</span><br><span class="line">        chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line">        size+=chunk.<span class="property">length</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks , size);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!size)&#123;</span><br><span class="line">            res.<span class="title function_">writeHead</span>(<span class="number">404</span>);</span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> rems = [];        </span><br><span class="line">        <span class="comment">// 根据 \ r\n 分离数据和报头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;buffer.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> v = buffer[i];</span><br><span class="line">            <span class="keyword">let</span> v2 = buffer[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">13</span> &amp;&amp; v2 == <span class="number">10</span>)&#123;</span><br><span class="line">                rems.<span class="title function_">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片信息</span></span><br><span class="line">        <span class="keyword">let</span> picmsg_1 = buffer.<span class="title function_">slice</span>(rems[<span class="number">0</span>]+<span class="number">2</span>,rems[<span class="number">1</span>]).<span class="title function_">toString</span>();</span><br><span class="line">        <span class="keyword">let</span> filename = picmsg_1.<span class="title function_">match</span>(<span class="regexp">/filename=&quot;.*&quot;/g</span>)[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27;&quot;&#x27;</span>)[<span class="number">1</span>];   </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片数据</span></span><br><span class="line">        <span class="keyword">let</span> nbuf = buffer.<span class="title function_">slice</span>(rems[<span class="number">3</span>]+<span class="number">2</span>,rems[rems.<span class="property">length</span>-<span class="number">2</span>]);        </span><br><span class="line">        <span class="keyword">let</span> path = <span class="variable constant_">APP_PATH</span> + <span class="string">&#x27;/public/images/avatar/&#x27;</span>+filename;</span><br><span class="line">        </span><br><span class="line">        fs.<span class="title function_">writeFileSync</span>(path , nbuf);</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; 保存 &quot;</span>+filename+<span class="string">&quot; 成功 &quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123;</span><br><span class="line">            <span class="attr">success</span>: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>2017年7月30日 <strong>更新</strong></p>
<p>今天又研究了下这个最后的这个方法，直接操作buffer的，惊讶发现把随文件传递的数据信息比如token、其它相关data一起当作图片数据存起来，竟然可以正常显示图片！(如图片所示，上传的文件正常显示，但是用记事本等打开可以发现下面存储了随文件一同传递的相关参数)</p>
<p><img src="/img/%E6%96%87%E4%BB%B6.png" alt="文件"></p>
<p><em>没研究过图片文件的数据啥的，感觉有点神奇</em></p>
<p>所以上方这个直接操作buffer的方法有点不太好，在 处理图片数据这块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nbuf = buffer.<span class="title function_">slice</span>(rems[<span class="number">3</span>]+<span class="number">2</span>,rems[rems.<span class="property">length</span>-<span class="number">2</span>]); </span><br></pre></td></tr></table></figure>

<p>这行代码有点问题。如果前端真的只传了文件倒是OK，没问题，如果还包含了其他重要的数据就又可能造成问题。图片可以正常存储显示，不过数据可能会不安全。</p>
<hr>
<p>总结来说，在后端处理文件的时候有两个方法</p>
<ol>
<li>直接使用<code>formidable</code>，简单方便。</li>
<li>操作buffer, 稍微复杂，不过只要知道了文件上传时数据格式就简单了。需要注意在操作类似图片的文件时，最好直接操作buffer，不要随意转码。</li>
</ol>
<p><br><br><br></p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>后端</tag>
        <tag>文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs+websocket实现随机聊天</title>
    <url>/2017/07/08/node/nodejs-websocket%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E8%81%8A%E5%A4%A9/</url>
    <content><![CDATA[<p><img src="/img/bitzoChat.png" alt="bitzoChat"></p>
<h1 id="导览"><a href="#导览" class="headerlink" title="导览"></a>导览</h1><p>用NodeJS写的基于websocket的web端在线聊天应用。</p>
<p>后端： Node.JS + mysql + redis</p>
<p>前端: bootstrap + angular</p>
<span id="more"></span>

<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p>GitHub：<a href="https://github.com/Bitzo/bitzoChat">bitzoChat</a></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这个项目我估计可能会是我这一段时间的主要目标了吧。只是希望自己能坚持下来，别做到一半扔了。</p>
<p>我给这个项目的定位是用来熟悉websocket，以此来练练手。</p>
<p>未来如果有机会的话其实想重新做，因为这次真的只是突发奇想就做起来了，对这方面的只是基本不懂，处于用起来但不理解的状态。未来重做的话，得花点时间想想如何设计，毕竟现在这个代码确实比较乱了。。。</p>
<p>前端的话，只能说凑合看吧，尽量写好看点。</p>
<h1 id="目前进展"><a href="#目前进展" class="headerlink" title="目前进展"></a>目前进展</h1><ul>
<li>实现简单注册登录</li>
<li>添加好友，删除好友</li>
<li>随机配对，进行聊天</li>
<li>单向好友系统</li>
</ul>
<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><ul>
<li>个人信息更改</li>
<li>修改好友模块，更改为双向好友</li>
<li>好友在线情况</li>
<li>在线好友直接聊天</li>
<li>非在线好友留言</li>
<li>界面优化</li>
<li>……</li>
</ul>
<h1 id="对webSocket的一点感悟"><a href="#对webSocket的一点感悟" class="headerlink" title="对webSocket的一点感悟"></a>对webSocket的一点感悟</h1><p>传统的HTTP协议是一种无状态的协议，只能实现由客户端向服务器端的单向请求（访问），而要让服务器主动向客户端发送消息是不可能的事， 在websocket的帮助下，服务器和客户端可以双向发送消息。</p>
<p>在做这个聊天工具时，每次请求建立一个ws连接后，都将此次的ws连接添加到ws的集合中，说是集合，不过我更倾向于直接用数组，或者map，key直接设置为请求用户的唯一标识，这样在需要的时候取出更方便。</p>
<p>在写的过程中，遇到的一个问题是我发现不能直接通过ws发送数组或者对象。。。<br>而只能发<code>binary</code>或者<code>string</code>，这个让我挺困扰的，一开始我还在纠结，后来想想直接<code>JSON.stringify</code>，收到了在<code>JSON.parse()</code>就好啦。这样就和普通在写http的接口啥的没什么不同了。</p>
<p>再者主要的问题就是ws的连接问题，在后端向前端发送消息时，一定要注意的是此ws的状态，要么选择判断其状态，要么得注意异常捕获，否则程序得挂→_→。。。</p>
<p>下面还有很多功能需要实现，再次期间，准备还要多花点时间多去了解了解ws。</p>
<p>不仅是ws，想想这学期计算机网络的考试成绩就心痛，得补补计算机网络了。。</p>
<p><br><br><br></p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs多进程</title>
    <url>/2017/09/11/node/nodejs%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>《深入浅出NodeJS》—— 朴灵 玩转进程篇的部分笔记</p>
</blockquote>
<span id="more"></span>

<h1 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h1><p>使用nodejs自带进程相关的模块复制进程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">fork</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cpus = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).<span class="title function_">cpus</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpus.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="title function_">fork</span>(<span class="string">&#x27;./worker.js&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> port = <span class="title class_">Math</span>.<span class="title function_">floor</span>((<span class="title class_">Math</span>.<span class="title function_">random</span>() + <span class="number">1</span> ) * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(port);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span> + <span class="number">10</span>));</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;)</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(port);</span><br></pre></td></tr></table></figure>

<p><code>node mastar.js</code> 程序依据当前机器上的CPU数量，复制出数量相当的node进程数。每个进程监听1000-2000的随机四个端口。</p>
<ul>
<li>这种模式叫做<strong>主从模式</strong>。</li>
<li>这是典型的分布式架构中用于并行处理业务的模式，具有较好的可伸缩性和稳定性。</li>
<li>主进程负责调度或管理工作进程，不负责具体的业务处理，进程趋于稳定。</li>
<li>工作进程负责具体的业务处理，工作进程需要关注其稳定性。</li>
</ul>
<h2 id="创建子进程的方法"><a href="#创建子进程的方法" class="headerlink" title="创建子进程的方法"></a>创建子进程的方法</h2><ol>
<li>spawn()： 启动一个子进程来执行命令。</li>
<li>exec()： 启动一个子进程来执行命令，与spawn()不同的时其接口不同，他有一个回调函数获知子进程的状况。</li>
<li>execFile()： 启动一个子进程来执行可执行文件。</li>
<li>fork()： 与spawn()类似，不同在于它创建的node的子进程只需制定要执行的JS文件模块即可。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">cp.<span class="title function_">spawn</span>(<span class="string">&#x27;node&#x27;</span>, [<span class="string">&#x27;workder.js&#x27;</span>]);</span><br><span class="line">cp.<span class="title function_">exec</span>(<span class="string">&#x27;node worker.js&#x27;</span>, <span class="function">(<span class="params">err, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">cp.<span class="title function_">execFile</span>(<span class="string">&#x27;worker.js&#x27;</span>, <span class="function">(<span class="params">er, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">cp.<span class="title function_">fork</span>(<span class="string">&#x27;./worker.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>对于child_process模块，通过fork()或者其他API,创建子进程后，父进程与子进程之间建立IPC通道，通过IPC通道，父子进程之间通过message()和send()传递消息。</p>
<p>这是一种通过消息传递内容，而不是共享或直接操作相关资源的方法，比较轻量无依赖。<br>但是send()方法第二个参数已可以传递句柄（一种标示资源的引用），以实现更复杂的应用。</p>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>IPC（Inter-Process Communication）进程间通信。</p>
<p>实现进程间通信的方法有：命名管道，匿名管道，socket，信号量，共享内存，消息队列，Domain Socket等。</p>
<p>Nodejs中IPC由管道（PIPE）技术实现，具体细节由libuv提供，win下命名管道实现，* nix下Unix Domian Socket实现。</p>
<h3 id="IPC创建步骤"><a href="#IPC创建步骤" class="headerlink" title="IPC创建步骤"></a>IPC创建步骤</h3><ul>
<li>父进程创建子进程前，会先创建IPC并监听。</li>
<li>创建子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC的文件描述符。</li>
<li>子进程启动过程中，通过文件描述符去连接IPC通道。</li>
</ul>
<p><strong>只有子进程时node进程时，子进程才会连接IPC通道，其他类型的进程无法实现此种方法的进程通信，除非其他进程也按照上述约定去连接IPC通道。</strong></p>
<h2 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h2><p>问题：<br>每一个进程启动时监听不同的端口，主进程要接收所有的网络请求，再将请求代理到不同端口的子进程上，这种方法虽然可以避免端口重复的问题，甚至可以适当的均衡负载，但是由于进程每收到一个连接，将会用掉一个文件描述符，这种代理模式，则会浪费掉多出一倍的文件描述符。而操作系统的文件描述符是有限的，这种法师影响了系统的扩展能力。</p>
<p>解决方法：<br>通过send方法的第二个参数，可以向进程发送句柄（即标示某资源的引用），使主进程收到socket请求后，将这个请求直接发送给工作进程，而不是重新与工作进程建立新的socket连接来发送数据。</p>
<p><img src="/img/%E5%8F%A5%E6%9F%841.jpg" alt="句柄传送"><br><img src="/img/%E5%8F%A5%E6%9F%842.jpg" alt="句柄传送"><br><img src="/img/%E5%8F%A5%E6%9F%843.jpg" alt="句柄传送"></p>
<p>当主进程将服务器句柄发给子进程后，关闭服务器的监听，则会发现所有的子进程都能监听到同一个端口了。</p>
<p><img src="/img/%E5%8F%A5%E6%9F%844.jpg" alt="句柄传送"></p>
<h2 id="相关解释"><a href="#相关解释" class="headerlink" title="相关解释"></a>相关解释</h2><ul>
<li><p>发送的句柄不是真的对象，而是句柄文件描述符。<br>由于底层细节不被应用层感知，所以在子进程中，开发者会有种服务器就是从父进程直接传递过来的感觉。Node进程之间只传递消息，不传递对象，这种错觉时<strong>抽象封装</strong>的结果。</p>
</li>
<li><p>Node目前只接受以下几种句柄类型：</p>
<ul>
<li>net.Socket: TCP套接字</li>
<li>net.Server: TCP服务器</li>
<li>net.Native: C++层面的TCP套接字或IPC管道</li>
<li>dgram.Socket: UDP套接字</li>
<li>dgram.Native: C++层面的UDP套接字</li>
</ul>
</li>
<li><p>由于独立启动的进程直接并不知道文件描述符，所以监听相同端口会失败。但当使用send发送句柄从而还原出来的服务，它们的文件描述符时相同的，所以监听相同的端口不会引起异常。</p>
</li>
<li><p>多个应用监听相同的端口时，文件描述符同一时间只能被一个进程使用，<br>所以当有一个请求向服务端发送后，即使有多个应用监听同个端口，也只有一个进程为其服务，这些进程服务时 <strong>抢占式</strong> 的。</p>
</li>
</ul>
<p><strong>补补操作系统去→_→</strong><br>…..<br><br></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ES6： Set&amp;Map</title>
    <url>/2018/03/08/node/set-map/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://es6.ruanyifeng.com/#docs/set-map">http://es6.ruanyifeng.com/#docs/set-map</a></p>
</blockquote>
<span id="more"></span>

<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><strong>类似数组，成员值唯一。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">[...items]; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line">items.<span class="property">size</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">items.<span class="title function_">add</span>(<span class="number">6</span>);</span><br><span class="line">item.<span class="property">size</span>; <span class="comment">// 6</span></span><br><span class="line">items.<span class="title function_">add</span>(<span class="number">6</span>);</span><br><span class="line">item.<span class="property">size</span>; <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="衍生技巧"><a href="#衍生技巧" class="headerlink" title="衍生技巧"></a>衍生技巧</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">arr.<span class="property">length</span>; <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line">arr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line">arr.<span class="property">length</span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line">arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br><span class="line">arr.<span class="property">length</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="…-set-gt-map-filter"><a href="#…-set-gt-map-filter" class="headerlink" title="… + set =&gt; map filter"></a>… + set =&gt; map filter</h3><p>扩展运算符 <code>...</code> 和 <code>Set</code> 结构相结合，就可以间接的使用 map, filter 等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// &#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>向 <code>Set</code> 添加元素时，不发生类型转换。</li>
<li><code>NaN</code> 只能添加一个。</li>
<li><code>&#123;&#125;</code> 空对象总是不相等。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">s.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">8</span>);</span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">s.<span class="title function_">add</span>(<span class="title class_">NaN</span>);</span><br><span class="line">s.<span class="title function_">add</span>(<span class="title class_">NaN</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="property">size</span>; <span class="comment">// 5</span></span><br><span class="line">s; <span class="comment">// &#123;&#123;&#125;, &#123;&#125;, 8, &#x27;8&#x27;, NaN&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Set</code> 遍历顺序即插入顺序。</li>
<li><code>Set</code> 键名键值相同。</li>
<li>目前无法在遍历<code>Set</code>的过程中，同步改变原有的结构。</li>
</ul>
<h2 id="常用方法及属性"><a href="#常用方法及属性" class="headerlink" title="常用方法及属性"></a>常用方法及属性</h2><table>
<thead>
<tr>
<th align="left">方法或属性</th>
<th align="left">作用</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Set.size</code></td>
<td align="left">返回成员总数</td>
<td align="left">Number</td>
</tr>
<tr>
<td align="left"><code>Size.add(value)</code></td>
<td align="left">添加value</td>
<td align="left">Set</td>
</tr>
<tr>
<td align="left"><code>Size.delete(value)</code></td>
<td align="left">删除成员</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left"><code>Size.has(value)</code></td>
<td align="left">判定value是否是成员</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left"><code>Size.clear()</code></td>
<td align="left">清空</td>
<td align="left">undefined</td>
</tr>
</tbody></table>
<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>与 <code>Set</code> 类似， 但 <code>WeakSet</code> 中的成员<strong>只能是对象，不能是别的类型值</strong>。</p>
<p><em>当试图添加其它类型值时，会抛出TypeError异常。</em></p>
<p><code>WeakSet</code> 不可遍历。</p>
<p><code>WeakSet</code> 中的对象都是<strong>弱引用</strong>，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用，也就是说，<strong>如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中</strong>。</p>
<p><code>WeakSet</code> 没有 <code>size</code> 属性和遍历方法。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><ul>
<li>对象，键值对的集合。</li>
<li>键不再仅限于字符串。</li>
<li>当键为对象时，只有对同一个对象的引用，<code>Map</code> 结构才将其视为同一个键。</li>
<li>当键为简单类型值，只要两个值严格相等，则视为同一个键。</li>
<li><code>NaN</code> 视为同一键。</li>
</ul>
<h2 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h2><table>
<thead>
<tr>
<th align="left">属性或方法</th>
<th align="left">作用</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>size</code></td>
<td align="left">返回成员总数</td>
<td align="left">Number</td>
</tr>
<tr>
<td align="left"><code>set(key, value)</code></td>
<td align="left">设置键名为key，值为value的成员</td>
<td align="left">Map</td>
</tr>
<tr>
<td align="left"><code>get(key)</code></td>
<td align="left">读取key对应的成员值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>has(key)</code></td>
<td align="left">是否有键值为key的成员</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left"><code>delete(key)</code></td>
<td align="left">删除key对应的成员</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left"><code>clear()</code></td>
<td align="left">清空</td>
<td align="left">undefined</td>
</tr>
</tbody></table>
<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><ul>
<li>只接受对象作为键名（不包括<code>null</code>），不接受其它类型作为键名</li>
<li>其他参考WeakSet。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>es6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2017/10/11/node/promise/</url>
    <content><![CDATA[<div class="post-body" itemprop="articleBody" style="opacity: 1; display: block; transform: translateY(0px);">

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><a href="#Promise" title="Promise"></a>Promise</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN: promise</a></p>
<p>顾名思义，<code>Promise</code>意为一种承诺，表明承诺做完一件事，要么成功要么失败，对应每一种结果，我都承诺会给予相应的回应（即解决方法）。</p>
<p>ES6 已自身实现了<code>Promise</code>，可以直接使用。</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><code>Promise</code>对象对应着三种状态，即<code>PENDING</code>(进行中，还未有结果)，<code>FULFILLED</code>(完成态),<code>REJECTED</code>(失败)。</li>
<li><code>Promise</code>对象的状态可以由<code>PENDING</code>→<code>FULFILLED</code>或<code>PENDING</code>→<code>REJECTED</code>转换，且一旦转换，则不再改变。</li>
<li><code>Promise</code>对象一旦发生了改变，即使再对其添加回调，也会立刻得到该结果。（_测试发现确实是这样，但是还不能确定自己理解是正确的_）</li>
<li><code>Promise</code>对象一定有<code>then</code>方法，用以对对象的状态改变后，做出相应的回应。</li>
<li><code>Promise</code>一旦执行则无法中途取消。</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(val);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数 <strong>executor</strong><br>executor 是一个带有 resolve 和 reject 两个参数的函数 。<strong>executor 函数在 Promise 构造函数执行时同步执行</strong>，被传递 resolve 和 reject 函数（executor 函数在 Promise 构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将 promise 的状态改为 fulfilled（完成）或 rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用 resolve 函数来将 promise 状态改成 fulfilled，或者在发生错误时将它的状态改为 rejected。<br>如果在 executor 函数中抛出一个错误，那么该 promise 状态为 rejected。executor 函数的返回值被忽略。</p>
</blockquote>
<h2 id="Promise-简单功能实现"><a href="#Promise-简单功能实现" class="headerlink" title="Promise 简单功能实现"></a>Promise 简单功能实现</h2><p>此处代码高度参考 <a href="https://github.com/Bitzo/node-practice/blob/master/control/promise/README.md">Github:ElemeFE/node-practice</a></p>
<p>看了好两边遍，自己倒是也尝试着写了好几遍 = =。。实现起来还是感觉很生疏。。每到最后实现多个 then 的时候就会出现问题。。可能自己是真的蠢。。/ 尴尬</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promisee</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> status = <span class="variable constant_">PENDING</span>;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> handler = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    value = err;</span><br><span class="line">    status = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">    handler.<span class="title function_">forEach</span>(next);</span><br><span class="line">    handler = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = <span class="keyword">typeof</span> value.<span class="property">then</span> == <span class="string">&#x27;function&#x27;</span> ? value.<span class="property">then</span> : <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (then) &#123;</span><br><span class="line">        value.<span class="property">then</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [resolve, reject]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">fulfill</span>(v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fulfill</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    status = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">    value = val;</span><br><span class="line">    <span class="title function_">next</span>(handler);</span><br><span class="line">    handler.<span class="title function_">forEach</span>(next);</span><br><span class="line">    handler = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">&#123;onFulfill, onReject&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">PENDING</span>:</span><br><span class="line">      handler.<span class="title function_">push</span>(&#123;onFulfill, onReject&#125;);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">      onFulfill &amp;&amp; <span class="title function_">onFulfill</span>(value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">      onReject &amp;&amp; <span class="title function_">onReject</span>(value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">then</span> = <span class="function">(<span class="params">onFulfill, onReject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promisee</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123;</span><br><span class="line">        <span class="attr">onFulfill</span>: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="title function_">onFulfill</span>(val));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onReject</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="title function_">onReject</span>(err));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">callback</span>(resolve, reject);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Promisee</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>经常忘记的是 resolve 方法下，忽略了新对象的 then 方法上下文绑定。</li>
<li>目前对 then 方法实现这块的 next 调用，所谓的_参数拦截_？有点不太明白。这是第一次遇到这种写法。。</li>
<li>还没有做完备的参数检查等异常处理。</li>
</ul>
<h2 id="几个-Promise-方法"><a href="#几个-Promise-方法" class="headerlink" title="几个 Promise 方法"></a>几个 Promise 方法</h2><h3 id="Promise-prototype-catch-onRejected"><a href="#Promise-prototype-catch-onRejected" class="headerlink" title="Promise.prototype.catch(onRejected)"></a>Promise.prototype.catch(onRejected)</h3><p>指定发生错误时执行的回调。</p>
<p>它可以在 promise/then 中发生异常时，捕获异常并处理。<br><strong>Promise 对象的错误具有 “冒泡” 性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</strong><br>一般 then 方法里可以不用谢第二个 reject 的回调，可以只写 resolve 回调，然后直接在最后加上 catch 捕获异常。</p>
<p><img src="/img/promise_catch.png" alt="promise_catch"></p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>Promise.all() 接受一个 Iterable 参数，Iterable 对象的每个子项都是一个 Promise 实例，若不是，则调用 Promise.resolve() 方法将其转换。</p>
<p>Promise.all() 的状态由其 Iterable 对象的所有子项决定</p>
<ul>
<li>若所有子项都 FULFILLED，则 Promise.all() 的状态才变为 FULFILLED，其 Iterable 的所有子项的返回值组成一个数组，传递给 Promise.all() 的回调。</li>
<li>若有任意一个子项被 REJECT，则 Promise.all() 直接 REJECT，其中第一个被 REJECT 的子项的返回值传递给 Promise.all() 的回调。</li>
</ul>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>该方法形式上与 Promise.all() 有点类似，但时表现不一样。<br>Promise.race() 对于其参数 Iterable 对象，若有任意一个子项 FULFILLED，则 Promise.race() 也 FULFILLED，如有任意一个子项 REJECT，则 Promise.race() 也 REJECT。<br>即 Promise.race() 总是和其 Iterable 对象的第一个出结果的子项具有相同的状态。</p>
<h3 id="Promise-resolve-和-Promise-reject"><a href="#Promise-resolve-和-Promise-reject" class="headerlink" title="Promise.resolve() 和 Promise.reject()"></a>Promise.resolve() 和 Promise.reject()</h3><p>某峰的 ES6 入门这块写的还是很全的。。。<br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve">ECMAScript 6 入门</a><br>包括后面的<code>Promise.done()</code>，<code>Promise.finally()</code>以及<code>Promise.try()</code></p>
<br>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>nodejs</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ES6：函数扩展</title>
    <url>/2017/09/08/node/%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>es6中函数扩展</p>
<span id="more"></span>

<h1 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h1><p>ES6开始可以对函数参数列表添加默认值。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">a = <span class="number">1</span>, b = <span class="number">2</span></span>) &#123;</span><br><span class="line">  <span class="comment">//TODO...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置了默认值的参数应放在未赋默认值的参数后面(尾参数)。</strong></p>
<h2 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h2><p>与结构赋值相结合。</p>
<p>当函数参数中含有一个对象参数时，可设置<strong>双重默认值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">1</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">1</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func3</span>(<span class="params">&#123;x, y&#125; = &#123;x:<span class="number">1</span>, y:<span class="number">2</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func1</span>(&#123;<span class="attr">x</span>:<span class="number">10</span>, <span class="attr">y</span>:<span class="number">20</span>&#125;); <span class="comment">//10 20</span></span><br><span class="line"><span class="title function_">func2</span>(&#123;<span class="attr">x</span>:<span class="number">10</span>, <span class="attr">y</span>:<span class="number">20</span>&#125;); <span class="comment">//10 20</span></span><br><span class="line"><span class="title function_">func3</span>(&#123;<span class="attr">x</span>:<span class="number">10</span>, <span class="attr">y</span>:<span class="number">20</span>&#125;); <span class="comment">//10 20</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">func1</span>(); <span class="comment">//0 1</span></span><br><span class="line"><span class="title function_">func2</span>(); <span class="comment">// TypeError</span></span><br><span class="line"><span class="title function_">func3</span>(); <span class="comment">//1 2</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">func1</span>(&#123;&#125;); <span class="comment">//0 1</span></span><br><span class="line"><span class="title function_">func2</span>(&#123;&#125;); <span class="comment">//0 1</span></span><br><span class="line"><span class="title function_">func3</span>(&#123;&#125;); <span class="comment">//undefined undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">func1</span>(&#123;<span class="attr">x</span>:<span class="number">10</span>&#125;); <span class="comment">//10 1</span></span><br><span class="line"><span class="title function_">func2</span>(&#123;<span class="attr">x</span>:<span class="number">10</span>&#125;); <span class="comment">//10 1</span></span><br><span class="line"><span class="title function_">func3</span>(&#123;<span class="attr">x</span>:<span class="number">10</span>&#125;); <span class="comment">//10 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">func1</span>(&#123;<span class="attr">y</span>:<span class="number">10</span>&#125;); <span class="comment">//0 10</span></span><br><span class="line"><span class="title function_">func2</span>(&#123;<span class="attr">y</span>:<span class="number">10</span>&#125;); <span class="comment">//0 10</span></span><br><span class="line"><span class="title function_">func3</span>(&#123;<span class="attr">y</span>:<span class="number">10</span>&#125;); <span class="comment">//undefined 10</span></span><br></pre></td></tr></table></figure>

<h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h2><p>函数的length属性返回函数参数未指定默认值的参数个数。</p>
<p>length属性忽略函数参数中的扩展运算符。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>若参数默认值是一个变量，则该变量先在其左边的函数参数列表中寻找该变量值，未找到则在函数所在的作用域找，还找不到则报错。</p>
<h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><ul>
<li>形式 “…变量名”。</li>
<li>rest参数为一个数组，函数多余的参数都会存在这个参数中。</li>
<li>rest参数后不能再有其它参数。</li>
<li>rest参数为一个数组，所有数组特有的方法都可以用于这个变量。</li>
</ul>
<p><img src="https://mdn.mozillademos.org/files/15037/7dd52b92-3a8f-11e7-8040-f3a8f7d73e6d.png" alt="rest参数"></p>
<p>rest参数运用到了<code>扩展运算符</code>，形式为 <code>...</code>。<br>该运算符将一个数组变为参数序列。</p>
<h2 id="相关应用"><a href="#相关应用" class="headerlink" title="...相关应用"></a><code>...</code>相关应用</h2><h3 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr =  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, ...arr];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// [ 3, 4, 5, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="数组转参数序列"><a href="#数组转参数序列" class="headerlink" title="数组转参数序列"></a>数组转参数序列</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">appy</span>(<span class="literal">null</span>, numbers);</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(...numbers);</span><br></pre></td></tr></table></figure>
<h3 id="结构赋值-1"><a href="#结构赋值-1" class="headerlink" title="结构赋值"></a>结构赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[a, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p><strong>扩展运算符的参数只能放最后</strong></p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ol>
<li>箭头函数体内的this对象会在定义时捕获上下文的this值，而不是使用时调用其的对象。</li>
<li>不可用作构造函数。</li>
<li>不可以使用arguments对象，该对象在箭头函数内不存在，可以用rest。</li>
<li>箭头函数不能用作generator。</li>
</ol>
<p>下面内容摘录<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN-Arrow functions</a></p>
<ul>
<li>一个箭头函数表达式的语法比一个函数表达式更短，并且不绑定自己的 this，arguments，super 或 new.target。</li>
<li>返回一个对象时，函数体外要加圆括号</li>
<li>箭头函数表达式对非方法函数是最合适的</li>
<li>箭头函数在参数和箭头之间不能换行</li>
</ul>
<h1 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h1><p>尾调用即在某个函数的<strong>最后一步</strong>是调用另一个函数。调用后不能再出现如赋值/运算等操作。</p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>通过尾调用优化，可以优化函数的调用栈，但是前提时尾调用的函数不能使用到外层函数的内部变量。</p>
<p>尾调用优化需要开启<strong>严格模式</strong></p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>尾调用的时该函数本身即时尾递归。</p>
<p>由于递归非常消耗内存，有可能发生栈溢出，如果使用尾递归，则大大减少了内存占用。</p>
<p>不过递归函数改写成尾递归一般会造成函数较难理解，参数意义不明的问题。</p>
<p>解决方法：</p>
<p>一. 在尾递归函数之外再提供一个正常形式的函数。<br>二. 将尾递归函数<a href="https://zh.wikipedia.org/zh-hans/%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a>。</p>
<h1 id="尾逗号"><a href="#尾逗号" class="headerlink" title="尾逗号"></a>尾逗号</h1><ul>
<li>所谓尾逗号，就是允许函数等结构参数末尾添加一个逗号。</li>
<li>该特性主要时为版本管理服务。</li>
<li>函数参数不能仅有尾逗号。</li>
<li>使用了扩展运算符后不能使用尾逗号。</li>
<li>JSON还不支持尾逗号。</li>
<li>数组/函数参数/对象支持尾逗号。</li>
</ul>
<br>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ES6：字符串扩展</title>
    <url>/2017/07/18/node/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<blockquote>
<p>参考 <a href="http://es6.ruanyifeng.com/">阮一峰 《ES6 标准入门》</a></p>
</blockquote>
<h1 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h1><p>使用反引号<code>`</code>标识， 模版字符串可以填充普通字符串，也可以定义多行字符串。</p>
<ul>
<li>使用多行模版时，所有的空格缩进都会被保存在输出中。</li>
<li>使用<code>$&#123;&#125;</code>嵌入变量，<code>&#123;&#125;</code>中可以写任何js表达式。</li>
<li>模版中使用反引号用反斜杠<code>\</code>转义。</li>
</ul>
<span id="more"></span>

<h1 id="字符串遍历器"><a href="#字符串遍历器" class="headerlink" title="字符串遍历器"></a>字符串遍历器</h1><p>为字符串添加了Iterator，使之可以通过<code>for..of...</code>遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(letter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&quot;s&quot;</span></span><br><span class="line"><span class="comment">//&quot;t&quot;</span></span><br><span class="line"><span class="comment">//&quot;r&quot;</span></span><br><span class="line"><span class="comment">//&quot;i&quot;</span></span><br><span class="line"><span class="comment">//&quot;n&quot;</span></span><br><span class="line"><span class="comment">//&quot;g&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串扩展API"><a href="#字符串扩展API" class="headerlink" title="字符串扩展API"></a>字符串扩展API</h1><p>只记录我感觉常用或比较实用的部分。</p>
<h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p><strong>includes(str[, postion])</strong><br><strong>Function</strong>: 字符串中是否存在参数字符串<br><strong>return</strong>: boolean</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&#x27;javascript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">includes</span>(<span class="string">&#x27;av&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">includes</span>(<span class="string">&#x27;av&#x27;</span>, <span class="number">1</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">includes</span>(<span class="string">&#x27;av&#x27;</span>, <span class="number">3</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith()"></a>startsWith()</h2><p><strong>startsWith(str[, postion])</strong><br><strong>Function</strong>: 字符串是否以参数字符串开头<br><strong>return</strong>: boolean</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&#x27;javascript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">startsWith</span>(<span class="string">&#x27;ja&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">startsWith</span>(<span class="string">&#x27;av&#x27;</span>, <span class="number">1</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">startsWith</span>(<span class="string">&#x27;ja&#x27;</span>, <span class="number">1</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h2><p><strong>endsWith(str[, postion])</strong><br><strong>Function</strong>: 字符串是否以参数字符串结尾<br><strong>return</strong>: boolean</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&#x27;javascript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">endsWith</span>(<span class="string">&#x27;pt&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">endsWith</span>(<span class="string">&#x27;pt&#x27;</span>, <span class="number">1</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">endsWith</span>(<span class="string">&#x27;av&#x27;</span>, <span class="number">3</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p><strong>repeat(count)</strong><br><strong>Function</strong>: 将字符串重复count次 <em>count非整数会被向下取整，非数字会先转成数字</em><br><strong>return</strong>: string</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">3</span>)); <span class="comment">//&#x27;xxx&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">3.2</span>)); <span class="comment">//&#x27;xxx&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">3.6</span>)); <span class="comment">//&#x27;xxx&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">0</span>)); <span class="comment">//&#x27;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="string">&#x27;3&#x27;</span>)); <span class="comment">//&#x27;xxx&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<br>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>nodejs</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ES6：对象扩展</title>
    <url>/2017/09/10/node/%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>es6 对象扩展</p>
<span id="more"></span>

<h1 id="对象属性简洁表示"><a href="#对象属性简洁表示" class="headerlink" title="对象属性简洁表示"></a>对象属性简洁表示</h1><p>即只写属性名，属性值为属性名所代的变量。<br>属性和方法都可以。<br>某个方法若是generator，在简洁描述前加<code>*</code>。<br>用于简写函数的返回值和模块输出变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getPoint</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setItem</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  o[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getItem</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> o[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  o = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  getItem,</span><br><span class="line">  setItem,</span><br><span class="line">  clear,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h1><p>把表达式放在中括号内，表达式的结果作为属性名。</p>
<p><strong>属性名表达式与属性简介表示法不能同时使用，不过用作对象方法的时候，可以同时使用</strong></p>
<h1 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h1><p>方法的name属性返回函数名</p>
<ul>
<li>取值函数，返回<code>get 方法名</code>。</li>
<li>存值函数，返回<code>set 方法名</code>。</li>
<li>bind方法创造的函数，返回<code>bound 方法名</code>。</li>
<li>Function构造函数创造的函数，返回<code>anoymous 方法名</code>。</li>
<li>对象的方法是一个Symbol值，返回`Symbol值的描述。</li>
</ul>
<h1 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h1><p>方法用来比较两个值是否时严格相等的，与严格比较运算符（===）基本一致。</p>
<p>不同之处：</p>
<ol>
<li>+0不等于-0</li>
<li>NaN等于NaN</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> === -<span class="number">0</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h1><ul>
<li>用于将source对象所有的<strong>可枚举</strong>属性复制到target对象。</li>
<li><strong>不可枚举的及继承的属性不会被复制。</strong></li>
<li>相同属性名的属性，后面的属性值会覆盖前面的属性值。</li>
<li>该方法只能复制浅对象，对于嵌套的属性，该方法时直接替换目标对象中的相同属性名的属性。</li>
<li>该方法也可以用于数组，不过会将数组视为对象处理。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> source1 = &#123;<span class="attr">b</span>:<span class="number">3</span>,<span class="attr">c</span>:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123;<span class="attr">c</span>:<span class="number">5</span>,<span class="attr">d</span>:<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target); <span class="comment">//&#123; a: 1, b: 3, c: 5, d: 6 &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> sourceArr = [<span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(targetArr, sourceArr);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(targetArr); <span class="comment">//[ 4, 5, 3 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>为对象添加属性方法</li>
<li>克隆对象(仅克隆原始对象自身可枚举的属性，忽略继承属性)</li>
<li>合并多个对象</li>
<li>为属性设置默认值，并接受自定义赋值</li>
</ul>
<h1 id="属性的可枚举性及遍历"><a href="#属性的可枚举性及遍历" class="headerlink" title="属性的可枚举性及遍历"></a>属性的可枚举性及遍历</h1><p>对象的每一个属性都有一个描述对象，用于控制该属性的行为。<br>其中有一个属性为enumerable,描述了该属性是否可枚举。<br>ES6规定，所有Class的原型的方法都是不可枚举的。</p>
<h2 id="相关的遍历方法"><a href="#相关的遍历方法" class="headerlink" title="相关的遍历方法"></a>相关的遍历方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>返回值或操作</th>
</tr>
</thead>
<tbody><tr>
<td>for…in…</td>
<td>循环遍历对象自身的和继承的可枚举属性（不含Symbol）</td>
</tr>
<tr>
<td>Object.keys(obj)</td>
<td>返回一个数组，包括对象自身（不含继承）的可枚举属性（不含Symbol）</td>
</tr>
<tr>
<td>Object.getOwnPropertyNames(obj)</td>
<td>返回数组，包含对象自身的所有属性（不含Symbol，但包括不可枚举属性）</td>
</tr>
<tr>
<td>Object.getOwnPropertySymbols(pbj)</td>
<td>返回数组，包含对象自身的所有Symbol属性</td>
</tr>
<tr>
<td>reflect.ownKeys(obj)</td>
<td>返回数组，包含对象自身的 <strong>所有</strong> 属性</td>
</tr>
<tr>
<td>reflect.enumerate(obj)</td>
<td>返回Iterator对象，遍历对象自身的和继承的所有可枚举属性（不含Symbol）</td>
</tr>
</tbody></table>
<p>所有方法遍历的属性都遵守以下的次序规则：</p>
<ul>
<li>首先遍历所有属性名为数字的属性，按数字升序排序。</li>
<li>其次遍历所有属性名为字符串的属性，按生成时间升序排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按生成时间升序排序。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>nodejs</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程（一）</title>
    <url>/2017/06/05/node/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>笔记部分内容摘自 《深入浅出 Node.JS》 —— 朴灵</p>
</blockquote>
<h1 id="异步编程难点"><a href="#异步编程难点" class="headerlink" title="异步编程难点"></a>异步编程难点</h1><ul>
<li>异常处理</li>
<li>函数嵌套</li>
<li>阻塞代码</li>
<li>多线程</li>
<li>异步转同步 </li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="传统-try-catch-方法，只能捕获当次事件循环内的异常，-对callback执行时，无法再进行捕获。"><a href="#传统-try-catch-方法，只能捕获当次事件循环内的异常，-对callback执行时，无法再进行捕获。" class="headerlink" title="传统 try/catch 方法，只能捕获当次事件循环内的异常， 对callback执行时，无法再进行捕获。"></a>传统 try/catch 方法，只能捕获当次事件循环内的异常， 对callback执行时，无法再进行捕获。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="title function_">async</span>(callback);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>callback会在下一次事件循环时执行,callback中的异常不能正常捕获,而直接抛出,导致程序crash</p>
<p><strong>Sample:</strong></p>
<p><em>程序会因为未捕获error而崩溃</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">asyncFunc</span>(func);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunc</span> (callback) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;asyncFunc&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;func&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error Not Catch&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般将出现的异常或错误，作为回调函数的第一个实参返回，如果为空值，则表明异步调用没有异常抛出。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">async</span>(<span class="keyword">function</span>(<span class="params">err, results</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">//TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//TODO</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自行编写异步方法时需要遵循的原则：</p>
<ol>
<li>必须执行调用者传入的回调函数</li>
<li>正确传递回异常供调试者判断</li>
</ol>
</blockquote>
<h2 id="try-catch易对用户传递的回调函数进行异常捕获"><a href="#try-catch易对用户传递的回调函数进行异常捕获" class="headerlink" title="try/catch易对用户传递的回调函数进行异常捕获"></a>try/catch易对用户传递的回调函数进行异常捕获</h2><p><strong>Sample：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    req.<span class="property">body</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(string);</span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="title function_">callback</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本来是对JSON.parse()进行异常捕获，但是如果当callback中出现异常抛出，将会导致回调执行两次。</p>
<p>正确写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    req.<span class="property">body</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(string);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">callback</span>();</span><br></pre></td></tr></table></figure>

<h1 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h1><p>恶魔金字塔问题、回调地狱</p>
<h1 id="阻塞代码"><a href="#阻塞代码" class="headerlink" title="阻塞代码"></a>阻塞代码</h1><p>延时操作： setInterval()/setTimeout()<br>但是并不延迟后续代码的执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="title class_">Date</span>() - now &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被阻塞的代码</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种写法完全阻塞代码，破坏了事件循环的调度。再加上由于Node.js的单线程原因，CPU资源会完全被这段代码占用，导致任何其余请求都得不到相应。</p>
</blockquote>
<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>Node.js 单线程应用， 不能充分利用系统资源。<br>可通过多部署，子进程、集群等解决。在后面的学习中补充。</p>
<h1 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h1><blockquote>
<p>Node提供API大部分是异步，同步API较少，在同步需求下，需要借助库或编译等手段来实现。</p>
</blockquote>
<p></br></br></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程（二）</title>
    <url>/2017/06/06/node/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>笔记部分内容摘自 《深入浅出Node.JS》 —— 朴灵</p>
</blockquote>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>事件发布/订阅模式</li>
<li>Promise/Deferred模式</li>
<li>流程控制库</li>
</ul>
<h1 id="事件发布-订阅模式"><a href="#事件发布-订阅模式" class="headerlink" title="事件发布/订阅模式"></a>事件发布/订阅模式</h1><blockquote>
<p>常常用来解耦业务逻辑</p>
</blockquote>
<h2 id="Node-js内的实现"><a href="#Node-js内的实现" class="headerlink" title="Node.js内的实现"></a>Node.js内的实现</h2><p>Node自身提供的events模块，是事件发布/订阅模式的简单实现。<br>通过模块提供的监听、触发等方法实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订阅</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&quot;event1&quot;</span>, <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&quot;event&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>事件发布/订阅模式 可以将一个事件与多个回调关联起来。一个事件的发布，可以传递给所以正在侦听此事件的监听器(<em>数量设限，过多可能会导致内存泄漏</em>)执行。</p>
<span id="more"></span>

<h2 id="多异步依赖"><a href="#多异步依赖" class="headerlink" title="多异步依赖"></a>多异步依赖</h2><p>通过添加<strong>哨兵变量</strong>和<strong>偏函数</strong>的方式，来解决多异步协作的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只有在times个异步都处理完后才能调用callback</span></span><br><span class="line"><span class="keyword">var</span> allDone = <span class="keyword">function</span> (<span class="params">times, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>,</span><br><span class="line">        results = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">key, value</span>) &#123;</span><br><span class="line">        results[key] = value;</span><br><span class="line">        ++count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count === times) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="title function_">allDone</span>(times, callback);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可使用第三方模块 <code>EventProxy</code> 来解决事件订阅/发布模式的一些问题。<br><a href="https://github.com/JacksonTian/eventproxy">github</a> or  <a href="https://www.npmjs.com/package/eventproxy">npm</a></p>
</blockquote>
<h1 id="Promise-Deferred-模式"><a href="#Promise-Deferred-模式" class="headerlink" title="Promise/Deferred 模式"></a>Promise/Deferred 模式</h1><blockquote>
<p>Promise 是一种规范，Promise 都拥有一个叫做 then 的唯一接口，当 Promise 失败或成功时，它就会进行回调。<br>它代表了一种可能会长时间运行而且不一定必须完成的操作结果。这种模式不会阻塞和等待长时间的操作完成，而是返回一个代表了承诺的（promised）结果的对象。<br>Defferred 就是之后来处理回调的对象。二者紧密不可分割。</p>
</blockquote>
<p>Promise对象只要具备then()方法即可，对于then()方法，有以下几点要求：</p>
<ul>
<li>接受完成态、错误态的回调方法。</li>
<li>可选的支持progress事件回调作为第三个方法。</li>
<li>then()方法只接受function对象，其余对象直接被忽略。</li>
<li>then()方法须继续返回Promise对象，以实现链式调用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//then()方法的定义</span></span><br><span class="line"><span class="title function_">then</span>(fulfilledHandler, errorHandler, progressHandler)</span><br></pre></td></tr></table></figure>

<p>Deferred对象（延迟对象）以用来实现触发执行被Promise.then()保存起来的回调函数的地方。</p>
<p><img src="/img/Promise_Deferred_1.png" alt="Promise/Deferred模式 对象关系示意图"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Deffered</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">offWork</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        d.<span class="title function_">resolve</span>(<span class="string">&#x27;done----offWork&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d.<span class="property">promise</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">start</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Deffered</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">backHome</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        d.<span class="title function_">resolve</span>(<span class="string">&#x27;done----backhome&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d.<span class="property">promise</span>;</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Deffered</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">eatFood</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        d.<span class="title function_">resolve</span>(<span class="string">&#x27;done----eatFood&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d.<span class="property">promise</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eating&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="流程控制库"><a href="#流程控制库" class="headerlink" title="流程控制库"></a>流程控制库</h1><h2 id="尾触发与Next"><a href="#尾触发与Next" class="headerlink" title="尾触发与Next"></a>尾触发与Next</h2><blockquote>
<p>除了事件和Promise外，还有一类方法需要手工调用才能持续执行的后续调用的，我们将此方法叫做尾触发。<br>常见的关键词是Next。</p>
</blockquote>
<p>这种方法常用在Connect中间件中使用。<br>通过对代码改造，在每个方法后面增加next参数，以连续调用下一个中间件，行成处理流。</p>
<p>中间件机制使得在处理网络请求时，对请求进行过虑、验证、记录日志等功能，与具体业务代码解耦。</p>
<p><em>使用尾触发会导致任务串行执行，将串行的逻辑扁平化，由此不能很好的发挥出异步的优势。</em></p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><h3 id="异步的串行执行"><a href="#异步的串行执行" class="headerlink" title="异步的串行执行"></a>异步的串行执行</h3><p>Sample：通过series()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.<span class="title function_">series</span>([</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file3.txt&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="keyword">function</span> (<span class="params">err, results</span>) &#123;</span><br><span class="line">    <span class="comment">//results =&gt; [file1, file2, file3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>每个callback会在执行时将结果保存起来，然后执行下一个调用，当全部的调用结束，最后将全部的结果以数组的形式传递给最后的调用。过程中，有任何一个调用出现异常，就直接结束所有调用。</p>
<h3 id="异步的并行执行"><a href="#异步的并行执行" class="headerlink" title="异步的并行执行"></a>异步的并行执行</h3><p>Sample：parallel()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.<span class="title function_">parallel</span>([</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file3.txt&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="keyword">function</span> (<span class="params">err, results</span>) &#123;</span><br><span class="line">    <span class="comment">//results =&gt; [file1, file2, file3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>与series()类似，只是parallel()以并行方式执行。</p>
<h3 id="异步调用的依赖处理"><a href="#异步调用的依赖处理" class="headerlink" title="异步调用的依赖处理"></a>异步调用的依赖处理</h3><p>Sample：waterfall()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.<span class="title function_">parallel</span>([</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;UTF-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, content</span>) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(err, content);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">         fs.<span class="title function_">readFile</span>(args, <span class="string">&#x27;UTF-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, content</span>) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(err, content);</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">         fs.<span class="title function_">readFile</span>(args, <span class="string">&#x27;UTF-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, content</span>) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(err, content);</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="keyword">function</span> (<span class="params">err, results</span>) &#123;</span><br><span class="line">    <span class="comment">//results =&gt; results4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过这种方法实现异步的依赖处理。异步函数依次执行，将异步方法得出的结果作为参数传递给下一个调用。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>详情用法见<a href="http://caolan.github.io/async/">官方文档</a></p>
<h2 id="step"><a href="#step" class="headerlink" title="step"></a>step</h2><h3 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h3><p>只有一个接口step，step接受任意数量的任务，所有任务一次串行执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Step</span>(</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">readFile1</span>(<span class="params"></span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">readFile2</span>(<span class="params">err, content</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">readFile3</span>(<span class="params">err, content</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file3&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">done</span>(<span class="params">err, results</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在Step中用到了关键字this，他是Step内部的next()方法，将异步调用的结果传递给下一个任务作为参数并执行。</p>
<h3 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h3><p>使用step中的parallel()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Step</span>(</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">readFiles</span>(<span class="params"></span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="variable language_">this</span>.<span class="title function_">parallel</span>());</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="variable language_">this</span>.<span class="title function_">parallel</span>());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">done</span>(<span class="params">err, res1, res2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>并行执行，按异步调用结束的顺序，一次返回调用的结果。</p>
<p><strong>值得注意的是，如果异步方法的结果传回的是多个参数，Step()将只会取前两个参数</strong></p>
<h2 id="wind"><a href="#wind" class="headerlink" title="wind"></a>wind</h2><p>看了几个博客，都是一样的内容，目前还不太理解，暂时直接摘录的别人的博客内容。</p>
<p>摘自：<a href="http://purplebamboo.github.io/2014/04/08/nodejs-async/#wind-js">purplebamboo’s blog</a></p>
<p>还有种比较知名的方式，是国内的程序员老赵的 wind.js, 它使用了一种完全不同的异步实现方式。前面的所有方式都要改变我们正常的编程习惯，但是 wind.js 不用。它提供了一些服务函数使得我们可以按照正常的思维去编程。</p>
<p>下面是一个简单的冒泡排序的算法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compare = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> swap = <span class="keyword">function</span> (<span class="params">a, i, j</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = a[i]; a[i] = a[j]; a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bubbleSort = <span class="keyword">function</span> (<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; array.<span class="property">length</span> - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">compare</span>(array[j], array[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="title function_">swap</span>(array, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单就不讲解了，现在的问题是我们如果要做一个动画，一点点的展示这个过程呢。<br>于是我们需要给 compare 加个延时，并且 swap 后重绘数字展现。<br>可 javascript 是不支持 sleep 这样的休眠方法的。如果我们用 setTimeout 模拟，又不能保证比较的顺序的正确执行。</p>
<p>可是有了 windjs 后我们就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compareAsync = <span class="built_in">eval</span>(<span class="title class_">Wind</span>.<span class="title function_">compile</span>(<span class="string">&quot;async&quot;</span>, <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    $await(<span class="title class_">Wind</span>.<span class="property">Async</span>.<span class="title function_">sleep</span>(<span class="number">10</span>)); <span class="comment">// 暂停10毫秒</span></span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> swapAsync = <span class="built_in">eval</span>(<span class="title class_">Wind</span>.<span class="title function_">compile</span>(<span class="string">&quot;async&quot;</span>, <span class="keyword">function</span> (<span class="params">a, i, j</span>) &#123;</span><br><span class="line">    $await(<span class="title class_">Wind</span>.<span class="property">Async</span>.<span class="title function_">sleep</span>(<span class="number">20</span>)); <span class="comment">// 暂停20毫秒</span></span><br><span class="line">    <span class="keyword">var</span> t = a[i]; a[i] = a[j]; a[j] = t;</span><br><span class="line">    <span class="title function_">paint</span>(a); <span class="comment">// 重绘数组</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bubbleSortAsync = <span class="built_in">eval</span>(<span class="title class_">Wind</span>.<span class="title function_">compile</span>(<span class="string">&quot;async&quot;</span>, <span class="keyword">function</span> (<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; array.<span class="property">length</span> - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 异步比较元素</span></span><br><span class="line">            <span class="keyword">var</span> r = $await(<span class="title function_">compareAsync</span>(array[j], array[j + <span class="number">1</span>]));</span><br><span class="line">            <span class="comment">// 异步交换元素</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">0</span>) $await(<span class="title function_">swapAsync</span>(array, j, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>注意其中最终要的几个辅助函数：</p>
<ol>
<li>eval(Wind.compile(“async”, func) 这个函数用来定义一个 “异步函数”。这样的函数定义方式是 “模板代码”，没有任何变化，可以认做是 “异步函数” 与 “普通函数” 的区别。</li>
<li>Wind.Async.sleep() 这是 windjs 对于 settimeout 的一个封装，就是用上面的 eval(Wind.compile 来定义的。</li>
<li>$await() 所有经过定义的异步函数，都可以使用这个方法 来等待异步函数的执行完毕。</li>
</ol>
<p>这样上面的代码就可以很容易的理解了。compare，swap 都被弄成了异步函数，然后使用 $await 等待他们的执行完毕。可以看到跟我们之前的写法比起来，实现思路几乎一样，只是多了些辅助函数。相当的创新。</p>
<blockquote>
<p>windjs 的实现原理，暂时没怎么看，这是一种预编译的思路。之后有空看看也来实现一个简单的 demo。</p>
</blockquote>
<br/>

<p><strong>无聊小记</strong></p>
<p>想起来以前看到别人写过的一个排序算法 —— sleepSort 挺搞笑的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">11</span>, <span class="number">42</span>, <span class="number">23</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(num), num);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><p>直接看代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fib</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//one method</span></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = <span class="title function_">fib</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(third); <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sixth); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//the onther</span></span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">fib</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">//object &#123;value: &#x27;0&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">//object &#123;value: &#x27;1&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">//object &#123;value: &#x27;1&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">//object &#123;value: &#x27;2&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">//object &#123;value: &#x27;3&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">//object &#123;value: &#x27;5&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">//object &#123;value: &#x27;8&#x27;, done: false&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>function* funcName(...params)&#123;...&#125;</code>    生成器函数 function generator</p>
<p>不多说，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">MDN官方文档</a></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote>
<p>异步编程，在性能问题上尤其是 io 处理上是它的优势，但是同时也是它的劣势，大部分人都无法很好的组织异步代码。于是就出现了一大堆的库，来给它擦屁股。</p>
</blockquote>
<br>

<blockquote>
<p>世界上本没有嵌套回调，写的人多了，也便有了。</p>
</blockquote>
<p></br></br></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ES6：数值扩展</title>
    <url>/2017/07/19/node/%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<blockquote>
<p>参考 <a href="http://es6.ruanyifeng.com/">阮一峰 《ES6 标准入门》</a> </p>
</blockquote>
<h1 id="Number对象的扩展"><a href="#Number对象的扩展" class="headerlink" title="Number对象的扩展"></a>Number对象的扩展</h1><h2 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h2><p>Number.isFinite(number)<br><strong>Function</strong>: 检查参数是否为非无穷数值。<br><strong>return</strong>： boolean</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="number">10</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="title class_">NaN</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(-<span class="title class_">Infinity</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h2><p>Number.isNaN(number)<br><strong>Function</strong>: 检查参数是否为NaN。<br><strong>return</strong>： boolean</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">10</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">10</span>/<span class="number">0</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">10</span>/<span class="title class_">NaN</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;str&#x27;</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;10&#x27;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Number.isFinite() 与 Number.isNaN() 对应了传统的 isFinite() 与 isNaN()， 其区别在于传统方法先将参数转为数值后再判断，而新方法只对数值有效，非数值参数一律返回false。</p>
</blockquote>
<p><img src="/img/%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95.png" alt="传统方法与ES6的区别"></p>
<h2 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h2><p>Number.isInteger(number)<br><strong>Function</strong>: 检查参数是否为Integer。<br><strong>return</strong>： boolean</p>
<p>该方法<strong>只对数值类型有效</strong>，非数值一律返回false。<br><strong>在JS内部，整数和浮点数是同样的储存方法，所以5和5.0视作同一值！</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">5</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">5.0</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">5.3</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="literal">true</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="string">&#x27;5&#x27;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="Number-isSafeInteger"><a href="#Number-isSafeInteger" class="headerlink" title="Number.isSafeInteger()"></a>Number.isSafeInteger()</h2><p>Number.isSafeInteger(number)<br><strong>Function</strong>: 检测参数（整数）是否在安全范围内<br><strong>return</strong>: boolean</p>
<p>安全数： number ∈ (-2^53, 2^53)</p>
<p>安全数常量：</p>
<ul>
<li>最大安全数： Number.MAX_SAFE_INTEGER</li>
<li>最小安全数： Number.MIN_SAFE_INTEGER</li>
</ul>
<blockquote>
<p>如果需要验证运算结果是否在安全整数范围内，<strong>不仅要验证运算结果，还要同时验证参与运算的每一个值</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trusty</span> (left, right, result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(left) &amp;&amp;</span><br><span class="line">        <span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(right) &amp;&amp;</span><br><span class="line">        <span class="title class_">Number</span>.<span class="title function_">isSafeInteger</span>(result)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Operation cannot be trusted!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><p><strong>ES6新增的Number对象中的常量： 极小常量</strong></p>
<p>用以在进行相应计算时设置一个误差范围。</p>
<br>

<h1 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h1><h2 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h2><p>Math.trunc(number)<br><strong>Function</strong>: 去除一个数的小数部分,反悔参数值的整数部分。<br><strong>return</strong>: Number</p>
<p><em>内部会对非数值参数先进行一次数值转换</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="number">3.2</span>); <span class="comment">//3</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">trunc</span>(-<span class="number">3.2</span>); <span class="comment">//-3</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="string">&quot;3.2&quot;</span>); <span class="comment">//3</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">trunc</span>(); <span class="comment">//NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="string">&quot;x&quot;</span>); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h2><p>Math.sign(number)<br><strong>Function</strong>: 判断参数是正数还是负数或者0<br><strong>return</strong>: </p>
<table>
<thead>
<tr>
<th>参数类型</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>正数</td>
<td>1</td>
</tr>
<tr>
<td>负数</td>
<td>-1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-0</td>
<td>-0</td>
</tr>
<tr>
<td>其它</td>
<td>NaN</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">sign</span>(<span class="number">3</span>); <span class="comment">//1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sign</span>(-<span class="number">3</span>); <span class="comment">//-1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sign</span>(<span class="number">0</span>); <span class="comment">//0</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sign</span>(-<span class="number">0</span>); <span class="comment">//-0</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sign</span>(<span class="string">&quot;x&quot;</span>); <span class="comment">//NaN </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sign</span>(<span class="string">&quot;3&quot;</span>); <span class="comment">//1 </span></span><br></pre></td></tr></table></figure>

<h2 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h2><p>Math.cbrt(number)<br><strong>Function</strong>: 计算参数立方根<br><strong>return</strong>: Number</p>
<p><em>内部会对非数值参数先进行一次数值转换</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">cbrt</span>(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">cbrt</span>(-<span class="number">1</span>); <span class="comment">//-1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">cbrt</span>(<span class="number">2</span>); <span class="comment">//1.2599210498948734</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">cbrt</span>(<span class="string">&#x27;27&#x27;</span>); <span class="comment">//3</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">cbrt</span>(<span class="string">&quot;x&quot;</span>); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h2><p>Math.hypot(number[, number1, number3, …])<br><strong>Function</strong>: 计算所有参数的平方和的算术平方根<br><strong>return</strong>: Number</p>
<p><em>内部会对所有非数值参数先进行一次数值转换，<strong>只要有一个参数转换失败，即返回NaN</strong></em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">hypot</span>(-<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">//5</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>); <span class="comment">//5</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="title class_">NaN</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">hypot</span>(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-expm1"><a href="#Math-expm1" class="headerlink" title="Math.expm1()"></a>Math.expm1()</h2><p>Math.expm1(x)<br><strong>Function</strong>: 计算<code>e^x-1</code>, 即<code>Math.exp(x) - 1</code><br><strong>return</strong>: Number</p>
<p><em>内部会对所有非数值参数先进行一次数值转换</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">expm1</span>(<span class="number">1</span>); <span class="comment">//1.718281828459045</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">expm1</span>(<span class="number">0</span>); <span class="comment">//0</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">expm1</span>(-<span class="number">1</span>); <span class="comment">//-0.6321205588285577</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">expm1</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">//1.718281828459045</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">expm1</span>(<span class="string">&#x27;x&#x27;</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">expm1</span>(<span class="string">&#x27;-1&#x27;</span>); <span class="comment">//-0.6321205588285577</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-log1p"><a href="#Math-log1p" class="headerlink" title="Math.log1p()"></a>Math.log1p()</h2><p>Math.log1p(x)<br><strong>Function</strong>: 计算<code>ln(1+x)</code>, 即<code>Math.log(x+1)</code>，x&lt;-1, 返回NaN<br><strong>return</strong>: Number</p>
<p><em>内部会对所有非数值参数先进行一次数值转换</em></p>
<h2 id="Math-log10"><a href="#Math-log10" class="headerlink" title="Math.log10()"></a>Math.log10()</h2><p>Math.log10(x)<br><strong>Function</strong>: 计算以10为底的x的对数，x&lt;0，返回NaN<br><strong>return</strong>: Number</p>
<p><em>内部会对所有非数值参数先进行一次数值转换</em></p>
<h2 id="Math-log2"><a href="#Math-log2" class="headerlink" title="Math.log2()"></a>Math.log2()</h2><p>Math.log2(x)<br><strong>Function</strong>: 计算以2为底的x的对数，x&lt;0，返回NaN<br><strong>return</strong>: Number</p>
<p><em>内部会对所有非数值参数先进行一次数值转换</em></p>
<h2 id="新增三角函数方法"><a href="#新增三角函数方法" class="headerlink" title="新增三角函数方法"></a>新增三角函数方法</h2><ul>
<li>Math.sinh(x): 返回x的双曲正弦</li>
<li>Math.cosh(x): 返回x的双曲余弦</li>
<li>Math.tanh(x): 返回x的双曲正切</li>
<li>Math.asinh(x): 返回x的反双曲正弦</li>
<li>Math.acosh(x): 返回x的反双曲余弦</li>
<li>Math.atanh(x): 返回x的反双曲正切</li>
</ul>
<p><em>内部会对所有非数值参数先进行一次数值转换</em></p>
<br>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>nodejs</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ES6：数组扩展</title>
    <url>/2017/07/31/node/%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<blockquote>
<p>参考 <a href="http://es6.ruanyifeng.com/">阮一峰 《ES6 标准入门》</a> </p>
</blockquote>
<span id="more"></span>

<h1 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from(obj[, func])</a><br><strong>Function</strong>: 将<strong>类似数组的对象</strong>或<strong>可遍历对象</strong>转为真正的数组。<br><strong>return</strong>: Array</p>
<ul>
<li>只要是部署了Iterator接口的数据结构，都可以转换。</li>
<li>特殊的<code>...</code>（扩展运算符）可以将部署了 <code>Symbol.iterator</code> 的对象转换成Array。</li>
<li>任何具有length属性的对象都可以转换，但是扩展运算符无法将其转换。</li>
<li>第二个参数可以传递一个方法，类似于map，对每个元素进行自定义处理后再放入数组。</li>
<li>方法只返回数组，并不改变原有对象。</li>
<li>对于类数组对象，可以指定length属性，决定最后产生的数组长度。</li>
</ul>
<h1 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of">Array.of(…element)</a><br><strong>Function</strong>: 将参数转换为数组<br><strong>return</strong>: Array</p>
<p><strong>该方法主要用以数组的构造，弥补原有的构造函数Array()的不足。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>); <span class="comment">//[3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span>; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>); <span class="comment">//[undefined × 3]</span></span><br><span class="line"><span class="title class_">Array</span>(); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<h1 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h1><p>[copyWithin(target[, start[, end]])](<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin</a>)<br><strong>Function</strong>: 在当前数组内部将指定位置的成员复制到其他位置，返回当前数组。<br><strong>return</strong>: array</p>
<ul>
<li>参数<code>target</code>： 数值，表述开始替换的位置。</li>
<li>参数<code>start</code>: 数值， 表示开始读取的数据，默认为0，为负值则表示倒数。</li>
<li>参数<code>end</code>: 数值， 表示结束读取的数据，默认为数组长度，为负值则表示倒数。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[].<span class="property">copyWithin</span>.<span class="title function_">call</span>(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//&#123;0:1, 3:1, length: 5&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="find-、findIndex"><a href="#find-、findIndex" class="headerlink" title="find()、findIndex()"></a>find()、findIndex()</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find">find(callback)</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">findIndex(callback)</a></p>
<p><strong>Function</strong>: 寻找到第一个符合条件的成员。<br><strong>return</strong>: 返回符合条件的成员 或 下标。</p>
<ul>
<li>回调函数共可以设置三个参数<code>value</code>、<code>index</code>、<code>arr</code></li>
<li>与<code>IndexOf()</code>不同， <code>find()</code>与<code>findIndex()</code>可以发现NaN。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>); <span class="comment">//-1</span></span><br><span class="line">[<span class="title class_">NaN</span>].<span class="title function_">findIndex</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(x)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h1 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h1><p>[fill(value[, start[, end]])](<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill</a>)<br><strong>Funtcion</strong>: 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。<br><strong>return</strong>: array</p>
<ul>
<li>用于空数组的初始化非常方便。</li>
<li>具体要填充的元素区间是 [start, end) , 一个半开半闭区间。</li>
<li>参数 <code>start</code> 为负数，则为倒数。</li>
<li>参数 <code>end</code> 为负数，则结束索引为 end+length。 </li>
</ul>
<p><br><br></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>nodejs</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ES6：解构赋值</title>
    <url>/2017/07/18/node/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>数组： <a href="http://www.bilibili.com/video/av6698380/index_3.html">http://www.bilibili.com/video/av6698380/index_3.html</a><br>对象： <a href="http://www.bilibili.com/video/av6698380/index_4.html">http://www.bilibili.com/video/av6698380/index_4.html</a><br>其他： <a href="http://www.bilibili.com/video/av6698380/index_5.html">http://www.bilibili.com/video/av6698380/index_5.html</a></p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>参考 <a href="http://es6.ruanyifeng.com/">阮一峰 《ES6 标准入门》</a> </p>
</blockquote>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>所谓解构赋值，就是将按照一定模式或结构，从数组或对象中提取值赋给相对应结构的变量</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>只要左右两边的括号模式相同，变量则可相应赋值。</p>
</li>
<li><p>如若解构失败，变量值为<code>undefined</code></p>
</li>
<li><p>若等号右边不是可遍历的结构，则报错</p>
</li>
</ul>
<p>一个斐波那契序列的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fib</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = <span class="title function_">fib</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(third); <span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sixth); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p><i>function *funcName(…params){…}<br>生成器函数 function generator</i> </p>
<h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><p>解构赋值允许使用默认值</p>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><ol>
<li><p>交换变量值</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></li>
<li><p>从函数中返回多个值</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">[x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [a, b, c] = [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="title function_">func</span>([<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li>
<li><p>函数的参数定义（<em>有序数组，无序对象</em>）</p>
<p> 数组：见上方例子</p>
<p> 对象：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">&#123;x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(&#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">1</span>, <span class="attr">z</span>:<span class="number">0</span>&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>提取JSON数据</p>
</li>
<li><p>设置函数参数默认值</p>
</li>
<li><p>遍历Map结构 <em>for…of…结构</em></p>
</li>
<li><p>加载模块的指定方法</p>
</li>
</ol>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构赋值时，大括号不能出现于行首，会被误认为是代码块，而造成语法错误。</span></span><br><span class="line">&#123;a, b&#125; = obj; <span class="comment">//Uncaught SyntaxError: Unexpected token =</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应该改成</span></span><br><span class="line">(&#123;a, b&#125; = obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>nodejs</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】迭代器模式</title>
    <url>/2022/07/13/design-pattern/iterator/</url>
    <content><![CDATA[<p>行为型设计模式: 迭代器模式 iterator</p>
<span id="more"></span>

<blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素, 而又不需要暴露该对象的内部表示. </p>
</blockquote>
<blockquote>
<p>PHP 标准库 (SPL) 定义了一个最适合此模式的接口迭代器！往往也需要实现 Countable 接口，允许在迭代器对象上使用  count($object)  方法。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateIterator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateIterator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$list</span> = [</span><br><span class="line">            <span class="string">&quot;a&quot;</span>,</span><br><span class="line">            <span class="string">&quot;b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c&quot;</span>,</span><br><span class="line">            <span class="string">&quot;d&quot;</span>,</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="variable">$list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyIterator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">First</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Next</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">IsDone</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">CurrentItem</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">MyIterator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$list</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$index</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$list</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="keyword">list</span> = <span class="variable">$list</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">First</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Next</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">IsDone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;index &gt;= <span class="title function_ invoke__">count</span>(<span class="variable">$this</span>-&gt;<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">CurrentItem</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="keyword">list</span>[<span class="variable language_">$this</span>-&gt;index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$agreegate</span> = <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>();</span><br><span class="line"><span class="variable">$iterator</span> = <span class="variable">$agreegate</span>-&gt;<span class="title function_ invoke__">CreateIterator</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="variable">$iterator</span>-&gt;<span class="title function_ invoke__">IsDone</span>()) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$iterator</span>-&gt;<span class="title function_ invoke__">CurrentItem</span>(), PHP_EOL;</span><br><span class="line">    <span class="variable">$iterator</span>-&gt;<span class="title function_ invoke__">Next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在 <code>Subject</code> 里仅注重其本身的业务逻辑, 对于观察者模式下对观察者的notify 操作改为 implement 一个接口来实现, 使其 observable ?</p>
<blockquote>
<p>SPL扩展实现观察者模式-完整源码：<br><a href="https://github.com/zhangyue0503/designpatterns-php/blob/master/06.observer/source/spl_observer.php">https://github.com/zhangyue0503/designpatterns-php/blob/master/06.observer/source/spl_observer.php</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】观察者模式</title>
    <url>/2022/07/13/design-pattern/observer/</url>
    <content><![CDATA[<p>行为型设计模式: 观察者模式 observer</p>
<span id="more"></span>

<blockquote>
<p>当对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。它使用的是低耦合的方式。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">Subject <span class="variable">$subject</span></span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$observerState</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">Subject <span class="variable">$subject</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;observerState = <span class="variable">$subject</span>-&gt;<span class="title function_ invoke__">getState</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;执行观察者操作！当前状态：&#x27;</span> . <span class="variable language_">$this</span>-&gt;observerState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$observers</span> = [];</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$stateNow</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attach</span>(<span class="params">Observer <span class="variable">$observer</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;observers, <span class="variable">$observer</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">detach</span>(<span class="params">Observer <span class="variable">$observer</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$position</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;observers <span class="keyword">as</span> <span class="variable">$ob</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$ob</span> == <span class="variable">$observer</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">array_splice</span>(<span class="variable">$this</span>-&gt;observers, (<span class="variable">$position</span>), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++<span class="variable">$position</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span>(<span class="params"></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;observers <span class="keyword">as</span> <span class="variable">$ob</span>) &#123;</span><br><span class="line">            <span class="variable">$ob</span>-&gt;<span class="title function_ invoke__">update</span>(<span class="variable">$this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params"><span class="variable">$state</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;stateNow = <span class="variable">$state</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">notify</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;stateNow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在 <code>Subject</code> 里仅注重其本身的业务逻辑, 对于观察者模式下对观察者的notify 操作改为 implement 一个接口来实现, 使其 observable ?</p>
<blockquote>
<p>SPL扩展实现观察者模式-完整源码：<br><a href="https://github.com/zhangyue0503/designpatterns-php/blob/master/06.observer/source/spl_observer.php">https://github.com/zhangyue0503/designpatterns-php/blob/master/06.observer/source/spl_observer.php</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】装饰器模式</title>
    <url>/2022/07/05/design-pattern/decorator/</url>
    <content><![CDATA[<p>结构性模式: 装饰模式 decorator</p>
<span id="more"></span>

<blockquote>
<p>动态地给一个<strong>对象</strong>添加一些额外的职责, 就增加功能来说, 装饰器模式相比生成子类更灵活</p>
</blockquote>
<p>不改变原有的功能, 不对原有的功能加限制, 不需要原有功能对新功能提供任何帮助, 仅在原有功能上添加新的功能</p>
<ul>
<li>给老系统进行升级扩展</li>
<li>不一定都是对同一个方法进行装饰，其实装饰者应该更多的用于对对象的装饰，对对象进行扩展, 增加功能方法, 削弱/减少功能方法</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HouseBuilderInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beautify</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> <span class="keyword">implements</span> <span class="title">HouseBuilderInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beautify</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;粉刷完成\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilderDecorator</span> <span class="keyword">implements</span> <span class="title">HouseBuilderInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$houseBuilder</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">HouseBuilderInterface <span class="variable">$houseBuilder</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;houseBuilder = <span class="variable">$houseBuilder</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBuilderDecoratorFloor</span> <span class="keyword">extends</span> <span class="title">HouseBuilderDecorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beautify</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;houseBuilder-&gt;<span class="title function_ invoke__">beautify</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;铺完地板啦\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBuilderDecoratorClean</span> <span class="keyword">extends</span> <span class="title">HouseBuilderDecorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">beautify</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;houseBuilder-&gt;<span class="title function_ invoke__">beautify</span>();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;打扫好啦\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$houseBuilder</span> = <span class="keyword">new</span> <span class="title class_">HouseBuilder</span>();</span><br><span class="line"><span class="variable">$houseBuilder</span>-&gt;<span class="title function_ invoke__">beautify</span>();</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="variable">$houseBuilder</span> = <span class="keyword">new</span> <span class="title class_">HouseBuilderDecoratorFloor</span>(<span class="variable">$houseBuilder</span>);</span><br><span class="line"><span class="variable">$houseBuilder</span>-&gt;<span class="title function_ invoke__">beautify</span>();</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="variable">$houseBuilder</span> = <span class="keyword">new</span> <span class="title class_">HouseBuilderDecoratorClean</span>(<span class="variable">$houseBuilder</span>);</span><br><span class="line"><span class="variable">$houseBuilder</span>-&gt;<span class="title function_ invoke__">beautify</span>();</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"></span><br><span class="line"><span class="variable">$houseBuilder</span> = <span class="keyword">new</span> <span class="title class_">HouseBuilder</span>();</span><br><span class="line"><span class="variable">$houseBuilder</span> = <span class="keyword">new</span> <span class="title class_">HouseBuilderDecoratorFloor</span>(<span class="variable">$houseBuilder</span>);</span><br><span class="line"><span class="variable">$houseBuilder</span> = <span class="keyword">new</span> <span class="title class_">HouseBuilderDecoratorClean</span>(<span class="variable">$houseBuilder</span>);</span><br><span class="line"><span class="variable">$houseBuilder</span>-&gt;<span class="title function_ invoke__">beautify</span>();</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】工厂模式</title>
    <url>/2022/07/02/design-pattern/factory/</url>
    <content><![CDATA[<p>创建型设计模式: 工厂模式 factory<br>简单工厂, 工厂方法, 抽象工厂</p>
<span id="more"></span>

<p>工厂模式</p>
<ol>
<li>简单工厂</li>
<li>工厂方法</li>
<li>抽象工厂</li>
</ol>
<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>上层逻辑将需要的实例类型给到工厂, 工厂根据需求返回对应的对象. 一般通过条件分支语句实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// factory code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params"><span class="variable">$type</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$product</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="variable">$type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="variable">$product</span> = <span class="keyword">new</span> <span class="title function_ invoke__">ProductA</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="variable">$product</span> = <span class="keyword">new</span> <span class="title function_ invoke__">ProductB</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$product</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// product code</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Show ProductA&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Show ProductB&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super code</span></span><br><span class="line"><span class="variable">$type</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line"><span class="variable">$factory</span> = <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line"><span class="variable">$product</span> = <span class="variable">$factory</span>-&gt;<span class="title function_ invoke__">getProduct</span>(<span class="variable">$type</span>);</span><br><span class="line"><span class="variable">$product</span>-&gt;<span class="title function_ invoke__">show</span>();</span><br></pre></td></tr></table></figure>

<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>摒弃简单工厂中的条件分支判断, 将对象的实例交给具体的工厂<br>将对象的创建延迟到子类中进行, 不对外暴露具体实例化了哪个类<br><strong>一个具体工厂类只能生成一种具体的产品类的对象，不同的具体工厂生成不同的产品，而不是像简单工厂中那样，一个工厂类可以生成多种不同产品类的对象</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// factory code</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">factoryMethod</span>(<span class="params"><span class="variable">$type</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$factory</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="variable">$type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="variable">$factory</span> = <span class="keyword">new</span> <span class="title function_ invoke__">FactoryA</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="variable">$factory</span> = <span class="keyword">new</span> <span class="title function_ invoke__">FactoryB</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$factory</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_ invoke__">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_ invoke__">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// product code</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Show ProductA&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Show ProductB&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super code</span></span><br><span class="line"><span class="variable">$factory</span> = <span class="title class_">Factory</span>::<span class="title function_ invoke__">factoryMethod</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable">$product</span> = <span class="variable">$factory</span>-&gt;<span class="title function_ invoke__">getProduct</span>();</span><br><span class="line"><span class="variable">$product</span>-&gt;<span class="title function_ invoke__">show</span>();</span><br></pre></td></tr></table></figure>

<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>和工厂方法很类似, 但是一个工厂可以生成多个产品</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// factory code</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">factoryMethod</span>(<span class="params"><span class="variable">$type</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$factory</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="variable">$type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="variable">$factory</span> = <span class="keyword">new</span> <span class="title class_">Factory1</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="variable">$factory</span> = <span class="keyword">new</span> <span class="title class_">Factory2</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$factory</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProductA</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProductB</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory1</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProductA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProductB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProductA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProductB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// product code</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductA</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showA</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showB</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">implements</span> <span class="title">ProductA</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Show ProductA1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">implements</span> <span class="title">ProductA</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Show ProductA2&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">implements</span> <span class="title">ProductB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Show ProductB1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">implements</span> <span class="title">ProductB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">showB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Show ProductB2&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super code</span></span><br><span class="line"><span class="variable">$factory</span> = <span class="title class_">Factory</span>::<span class="title function_ invoke__">factoryMethod</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable">$productA</span> = <span class="variable">$factory</span>-&gt;<span class="title function_ invoke__">getProductA</span>();</span><br><span class="line"><span class="variable">$productB</span> = <span class="variable">$factory</span>-&gt;<span class="title function_ invoke__">getProductB</span>();</span><br><span class="line"><span class="variable">$productA</span>-&gt;<span class="title function_ invoke__">showA</span>();</span><br><span class="line"><span class="variable">$productB</span>-&gt;<span class="title function_ invoke__">showB</span>();</span><br></pre></td></tr></table></figure>

<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><ol>
<li><p>简单工厂<br>简单工厂方法中，包括一个“抽象产品类”（该类可以是接口Interface，也可以是实际的类Class），所有需要的产品类都是该“抽象产品类”的子类（如果是接口的话，那么就是说所有产品类都继承了该接口）。<br>简单工厂一般只包含一个具体的工厂类，由该工厂类生成所有的产品类的对象。生成产品类的方法，其内部一般是类似于switch的结构，根据输入的标志，选择创建不同类型的对象。由于不知道创建的对象到底是哪个类的，所以方法的返回值的类型是“抽象产品类”。</p>
</li>
<li><p>工厂方法<br>抽象工厂中，包括“抽象工厂类”和“抽象产品类”，同时包含不只一个工厂类。所有的工厂类都必须是“抽象工厂类”的子类，所有的产品都必须是“抽象产品类”的子类。<br>和简单工厂比起来，工厂方法一般是从抽象工厂开始的。一般都是在抽象工厂类中提供一个静态方法，由该方法根据输入的标志，生成不同的具体工厂类，然后由具体的产品类生成具体的产品。注意，一个具体工厂类只能生成一种具体的产品类的对象，不同的具体工厂生成不同的产品，而不是像简单工厂中那样，一个工厂类可以生成多种不同产品类的对象。可以这么理解，在选择不同的具体工厂类的时候，就选择了生成的产品，相对于简单工厂，相当于将选择产品的动作提前了。<br>因为不知道创建的具体工厂类到底是哪一个，所以生成具体工厂类的静态方法的返回值的类型是“抽象工厂类”。具体工厂类生成产品类的方法，返回值的类型也要求是“抽象产品类”（因为前端调用的时候，需要使用同样的代码来访问）。</p>
</li>
<li><p>抽象工厂<br>抽象工厂和工厂方法很类似，区别如下：<br><strong>工厂方法模式：</strong><br>一个抽象产品类，可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类只能创建一个具体产品类的实例。<br><strong>抽象工厂模式：</strong><br>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类可以创建多个具体产品类的实例。<br><strong>区别：</strong><br>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。<br>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个</p>
</li>
</ol>
<blockquote>
<p><a href="https://www.pudn.com/news/628f8480bf399b7f351f046f.html">https://www.pudn.com/news/628f8480bf399b7f351f046f.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】原型模式</title>
    <url>/2022/10/31/design-pattern/prototype/</url>
    <content><![CDATA[<p>创建型模式: 原型模式 prototype</p>
<span id="more"></span>

<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】适配器模式</title>
    <url>/2022/07/10/design-pattern/adapter/</url>
    <content><![CDATA[<p>结构型设计模式: 适配器模式 adapter</p>
<span id="more"></span>

<blockquote>
<p>将一个类的接口转换成客户希望的另一个接口. 适配器模式使原本由于接口不兼容不能一起工作的那些类可以一起工作</p>
</blockquote>
<p>两种形式</p>
<ul>
<li>继承式</li>
<li>组合式</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Standard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaStandard</span> <span class="keyword">implements</span> <span class="title">Standard</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;220V&#x27;</span> . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Standard</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$china_standard</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$china_standard</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;china_standard = <span class="variable">$china_standard</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;china_standard-&gt;<span class="title function_ invoke__">output</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>困惑点: 感觉装饰器模式和适配器模式有点像? </p>
<ul>
<li>装饰器模式: 不改变原有的功能, 不对原有的功能加限制, 不需要原有功能对新功能提供任何帮助, 仅在原有功能上添加新的功能</li>
<li>适配器模式: 将一个类的接口转换成客户希望的另一个接口. 适配器模式使原本由于接口不兼容不能一起工作的那些类可以一起工作</li>
</ul>
<p>适配器模式与装饰器模式的区别</p>
<p>装饰器与适配器都有一个别名叫做 包装模式(Wrapper)，它们看似都是起到包装一个类或对象的作用，但是使用它们的目的很不一一样。适配器模式的意义是要将一个接口转变成另一个接口，它的目的是通过改变接口来达到重复使用的目的。<br>而装饰器模式不是要改变被装饰对象的接口，而是恰恰要保持原有的接口，但是增强原有对象的功能，或者改变原有对象的处理方式而提升性能。所以这两个模式设计的目的是不同的。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/296319765">适配器模式，装饰模式，代理模式异同，别再说看着都一样了！
</a></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2017/05/29/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="什么是-git"><a href="#什么是-git" class="headerlink" title="什么是 git"></a>什么是 git</h2><blockquote>
<p>Git 是目前世界上最先进的分布式版本控制系统</p>
</blockquote>
<h2 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p><a href="https://git-scm.com/downloads">官网</a>直接下载安装包</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>bash 下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;bitzo&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;bitzo@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure>

<p>生成的密钥会保存在 ~/.ssh/ 下.</p>
<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><h3 id="建立-git-仓库"><a href="#建立-git-仓库" class="headerlink" title="建立 git 仓库"></a>建立 git 仓库</h3><h4 id="本地创建"><a href="#本地创建" class="headerlink" title="本地创建"></a>本地创建</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ./myGitRepo</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<h4 id="本地-clone-远程"><a href="#本地-clone-远程" class="headerlink" title="本地 clone 远程"></a>本地 clone 远程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git[http]://xxxx.xxxx.xx:xxx/xxx.git</span><br></pre></td></tr></table></figure>
<h3 id="添加更改"><a href="#添加更改" class="headerlink" title="添加更改"></a>添加更改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add fileName</span><br></pre></td></tr></table></figure>
<h3 id="查看git仓库状态"><a href="#查看git仓库状态" class="headerlink" title="查看git仓库状态"></a>查看git仓库状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
<h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- fileName</span><br></pre></td></tr></table></figure>
<h3 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m<span class="string">&quot;edit you message&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="向远程仓库推送更改"><a href="#向远程仓库推送更改" class="headerlink" title="向远程仓库推送更改"></a>向远程仓库推送更改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="将本地仓库与远程连接"><a href="#将本地仓库与远程连接" class="headerlink" title="将本地仓库与远程连接"></a>将本地仓库与远程连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建分支并切换"><a href="#创建分支并切换" class="headerlink" title="创建分支并切换"></a>创建分支并切换</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branchName</span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout branchName</span><br></pre></td></tr></table></figure>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d branchName</span><br></pre></td></tr></table></figure>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete &lt;branchName&gt; <span class="comment"># git &gt;v1.7.0</span></span><br><span class="line"><span class="comment"># 否则</span></span><br><span class="line">git push origin :&lt;branchName&gt;</span><br></pre></td></tr></table></figure>
<h3 id="从远程版本库拉取最新版本"><a href="#从远程版本库拉取最新版本" class="headerlink" title="从远程版本库拉取最新版本"></a>从远程版本库拉取最新版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge branchName</span><br></pre></td></tr></table></figure>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff sourceBranch targetBranch</span><br></pre></td></tr></table></figure>
<h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard XXXXX <span class="comment"># 直接丢弃更改</span></span><br><span class="line">$ git reset --soft XXXXX <span class="comment"># 保留更改于缓存区</span></span><br><span class="line"></span><br><span class="line">$ git reflog <span class="comment"># 打印记录你的每一次操作记录, 便于后悔回退</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git revert 命令意思是撤销某次提交。</span></span><br><span class="line"><span class="comment"># 它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的</span></span><br><span class="line"><span class="comment"># 所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。</span></span><br><span class="line">$ git revert XXXXXXX <span class="comment"># revert 是撤销一次提交，所以后面的commit id是你需要回滚到的版本的前一次提交</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】策略模式</title>
    <url>/2022/07/04/design-pattern/strategy/</url>
    <content><![CDATA[<p>行为型设计模式: 策略模式 strategy</p>
<span id="more"></span>

<blockquote>
<p>定义一系列的算法, 把他们一个个封装起来, 并且使他们可以相互替换</p>
</blockquote>
<p>分离「策略」并使他们之间能互相快速切换。此外，这种模式是一种不错的继承替代方案（替代使用扩展抽象类的方式）。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Algorithm</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyAlgorithmA</span> <span class="keyword">implements</span> <span class="title">Algorithm</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyAlgorithmB</span> <span class="keyword">implements</span> <span class="title">Algorithm</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params">Algorithm <span class="variable">$algorithm</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$algorithm</span>-&gt;<span class="title function_ invoke__">calculate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="title class_">Client</span>();</span><br><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="title class_">Client</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">getResult</span>(<span class="keyword">new</span> <span class="title function_ invoke__">StrategyAlgorithmA</span>()) . PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$client</span>-&gt;<span class="title function_ invoke__">getResult</span>(<span class="keyword">new</span> <span class="title function_ invoke__">StrategyAlgorithmB</span>()) . PHP_EOL;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx反向代理（端口转发）</title>
    <url>/2017/07/28/server/nginx/</url>
    <content><![CDATA[<p>nginx配合nodejs做代理，进行端口转发。</p>
<span id="more"></span>

<h1 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>

<h2 id="nginx-文件结构"><a href="#nginx-文件结构" class="headerlink" title="nginx 文件结构"></a>nginx 文件结构</h2><ul>
<li>所有的配置文件都在 /etc/nginx 下，并且每个虚拟主机已经安排在了 /etc/nginx/sites-available 下</li>
<li>程序文件在 /usr/sbin/nginx</li>
<li>日志放在了 /var/log/nginx 中</li>
<li>并已经在 /etc/init.d/ 下创建了启动脚本 nginx</li>
<li>默认的虚拟主机的目录设置在了 /var/www/nginx-default (有的版本 默认的虚拟主机的目录设置在了 /var/www, 请参考 / etc/nginx/sites-available 里的配置)</li>
</ul>
<h1 id="启动-nginx"><a href="#启动-nginx" class="headerlink" title="启动 nginx"></a>启动 nginx</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/nginx start</span><br></pre></td></tr></table></figure>

<h1 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><ul>
<li><code>/etc/nginx/sites-available</code> 记录代理配置</li>
<li><code>/etc/nginx/sites-enabled</code> 启动已配置好的代理</li>
<li>先在 <code>/etc/nginx/sites-available</code> 配置代理</li>
<li>在 <code>/etc/nginx/sites-enabled</code> 下创建symbol link链接available下的配置文件以启用代理配置</li>
</ul>
<h2 id="主要配置"><a href="#主要配置" class="headerlink" title="主要配置"></a>主要配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听的端口号</span><br><span class="line">    listen 80;</span><br><span class="line">    </span><br><span class="line">    # 监听的域名</span><br><span class="line">    server_name: a.b.com;</span><br><span class="line">    </span><br><span class="line">    # 转发规则</span><br><span class="line">    localtion / &#123;</span><br><span class="line">        proxy_pass http://a.b.com:port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转发规则"><a href="#转发规则" class="headerlink" title="转发规则"></a>转发规则</h3><p>我用的是<code>nodejs</code>+<code>express</code>，内部已经定义了静态资源服务，所以可以直接将所有的请求直接转发给node服务，以作出相应。若非上游服务做静态资源服务，可以在<code>location</code>模块定义资源目录。</p>
<ul>
<li>location后的地址（rul匹配）十分灵活，接受正则。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    # 完全匹配  =</span><br><span class="line">    # 大小写敏感 ~</span><br><span class="line">    # 忽略大小写 ~*</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">    # 前半部分匹配 ^~</span><br><span class="line">    # 可以使用正则，如：</span><br><span class="line">    # location ~* \.(gif|jpg|png)$ &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    # 如果以上都未匹配，会进入这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>root  定义该匹配后的处理路径根目录</li>
<li>index 定义首页（按顺序，以此尝试访问） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /home/wwwroot/bitzo/;</span><br><span class="line">    index index.html index.htm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>反向代理：proxy_pass</li>
<li>还有其他相关的代理配置，等了解了再慢慢加在这。。。</li>
</ul>
<h2 id="一个坑"><a href="#一个坑" class="headerlink" title="一个坑"></a>一个坑</h2><p>在配置的时候我没注意，location里一直加着 <code>try_files $uri $uri/ =404</code>, 导致除了主页面，访问其他一切资源全部都404。之后将这条语句注释掉即可成功。目前还不太清楚为什么。惨惨惨。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>BiliBili 深入 PHP 内核源码学习笔记</title>
    <url>/2022/09/27/php/bilibili-php-kernal/</url>
    <content><![CDATA[<p>BiliBili 深入 PHP 内核源码学习笔记 </p>
<blockquote>
<p><a href="https://space.bilibili.com/592837309/channel/collectiondetail?sid=637954">https://space.bilibili.com/592837309/channel/collectiondetail?sid=637954</a></p>
</blockquote>
<span id="more"></span>
<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><ul>
<li>0x01 变量<blockquote>
<p>弱类型: 无需事先申明, 弱类型非无类型, 底层做了转换 -&gt; zval<br>强类型: 必须先申明后使用</p>
</blockquote>
</li>
<li>0x02 函数<blockquote>
<p>zend_function 结构: 用户函数/内部函数<br>模拟栈, 链表, call, ret</p>
</blockquote>
</li>
<li>0x03 类及对象<blockquote>
<p>成员属性 成员方法 类常量<br>对象创建, 复制, 销毁</p>
</blockquote>
</li>
<li>0x04 字符串<blockquote>
<p>C 字符串 -&gt; 字符数组<br>zend_string 核心结构 柔性数组</p>
</blockquote>
</li>
<li>0x05 HashTable<blockquote>
<p>PHP数组实现基础<br>镜面数据结构</p>
</blockquote>
</li>
<li>0x06 GC<blockquote>
<p>引用技术/写时复制<br>并不是所有的变量都会触发 GC</p>
</blockquote>
</li>
<li>0x07 静态变量<blockquote>
<p>非真正的静态变量, 而是指向静态变量的局部变量</p>
</blockquote>
</li>
<li>0x08 全局变量<blockquote>
<p>类似静态变量, 但略有不同</p>
</blockquote>
</li>
<li>0x09 基础语法的实现<blockquote>
<p>循环 判断(条件分支) jump系列 opcode 指令</p>
</blockquote>
</li>
<li>0x10 扩展开发<blockquote>
<p>PHP 模块, ZEND 扩展加载 运行原理<br>opcache 扩展源码</p>
</blockquote>
</li>
<li>0x11 内存<blockquote>
<p>内存池 线程安全</p>
</blockquote>
</li>
<li>0x12 词法 语法<blockquote>
<p>re2c yacc 状态机</p>
</blockquote>
</li>
<li>0x13 ZVM 虚拟机<blockquote>
<p>编译 执行</p>
</blockquote>
</li>
</ul>
<h1 id="PHP-生命周期"><a href="#PHP-生命周期" class="headerlink" title="PHP 生命周期"></a>PHP 生命周期</h1><p>取决于具体的 SAPI 的实现: PHP-CLI 或 PHP-FPM<br>共同点: 都经历5个主要阶段<br>区别: 部分阶段执行次数不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main()</span><br><span class="line">  -&gt; php_module_startup() </span><br><span class="line">  -&gt; php_request_startup() &lt;──┐</span><br><span class="line">  -&gt; php_execute_script()     │ fpm 多次循环 </span><br><span class="line">  -&gt; php_request_shutdown() ──┘ </span><br><span class="line">  -&gt; php_module_shutdown() </span><br></pre></td></tr></table></figure>

<h2 id="编写个扩展感受生命周期-x70-104-x70-x40-55-x2e-49-php-cli"><a href="#编写个扩展感受生命周期-x70-104-x70-x40-55-x2e-49-php-cli" class="headerlink" title="编写个扩展感受生命周期 (&#x70;&#104;&#x70;&#x40;&#55;&#x2e;&#49; php-cli)"></a>编写个扩展感受生命周期 (<a href="mailto:&#x70;&#104;&#x70;&#x40;&#55;&#x2e;&#49;">&#x70;&#104;&#x70;&#x40;&#55;&#x2e;&#49;</a> php-cli)</h2><p><code>/path/to/php/ext</code> 源码的扩展目录: <code>ext_skel</code> 脚本, 可以初始化一个自定义扩展脚手架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ext_skel --extname=EXT_NAME </span><br><span class="line"></span><br><span class="line">Creating directory EXT_NAME</span><br><span class="line">Creating basic files: config.m4 config.w32 .gitignore demo.c php_demo.h CREDITS EXPERIMENTAL tests/001.phpt demo.php [<span class="keyword">done</span>].</span><br><span class="line"></span><br><span class="line">To use your new extension, you will have to execute the following steps:</span><br><span class="line"></span><br><span class="line">1.  $ <span class="built_in">cd</span> ..</span><br><span class="line">2.  $ vi ext/demo/config.m4</span><br><span class="line">3.  $ ./buildconf</span><br><span class="line">4.  $ ./configure --[with|<span class="built_in">enable</span>]-demo</span><br><span class="line">5.  $ make</span><br><span class="line">6.  $ ./sapi/cli/php -f ext/demo/demo.php</span><br><span class="line">7.  $ vi ext/demo/demo.c</span><br><span class="line">8.  $ make</span><br><span class="line"></span><br><span class="line">Repeat steps 3-6 until you are satisfied with ext/demo/config.m4 and</span><br><span class="line">step 6 confirms that your module is compiled into PHP. Then, start writing</span><br><span class="line">code and repeat the last two steps as often as necessary.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_MINIT(demo),</span><br><span class="line">PHP_MSHUTDOWN(demo),</span><br><span class="line">PHP_RINIT(demo),    <span class="comment">/* Replace with NULL if there&#x27;s nothing to do at request start */</span></span><br><span class="line">PHP_RSHUTDOWN(demo),    <span class="comment">/* Replace with NULL if there&#x27;s nothing to do at request end */</span></span><br></pre></td></tr></table></figure>

<p>这里的具体操作是跟着视频流程走了一遍, 部分内容不能理解, 主要是在实现扩展的 c 文件里找到定义的生命周期的四个步骤里加了自定义的输出语句, 然后编译安装后在命令行下执行 php 脚本, 发现会输出自定义的语句, 以此来感受 php 在命令行下执行的生命周期</p>
<p>按照视频的教程所说, 空脚本执行后应该会输出的是: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php test.php</span><br><span class="line">&gt;&gt; module init...</span><br><span class="line">&gt;&gt; request init...</span><br><span class="line">&gt;&gt; request shutdown...</span><br><span class="line">&gt;&gt; module shutdown...</span><br></pre></td></tr></table></figure>
<p>但是我实际测试发现没有输出<code>module shutdown</code>, 但是执行如<code>php -i</code>或<code>php --version</code>之类的命令时, 则会输出<code>module shutdown</code>, 挺奇怪的, 暂时不理解原因, 先在这 mark 一下…</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
</search>
